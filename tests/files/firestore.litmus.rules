rules_version = '2';

 match /noCondition {
   allow read;
 }

 match /multipleActions {
   allow read, update: if true;
 }

 function trailingComma() {
   return [
     1,
   ]
 }


service cloud.firestore {
  match /databases/{database}/documents {

    // Core methods
    // -----------------------------

    function has(prop, data) {
      return data.keys().hasAll([ prop ])
    }

    function includes(value, list) {
      return list.hasAll([ value ])
    }

    function isBoolean(value) {
      return value is bool
    }

    function isBytes(value) {
      return value is bytes
    }

    function isConstraint(value) {
      return value is constraint
    }

    function isDuration(value) {
      return value is duration
    }

    function isFloat(value) {
      return value is float
    }

    function isHex(value) {
      return isString(value) &&
        value.matches('^[a-z0-9]+$')
    }

    function isImageContentType(value) {
      return isString(value) &&
        (
          value == 'image/jpg' ||
          value == 'image/jpeg' ||
          value == 'image/png'
        )
    }

    function isIndex(value) {
      return isInteger(value) && value >= 0
    }

    function isInteger(value) {
      return value is int
    }

    function isLatLng(value) {
      return value is latlng
    }

    function isList(value) {
      return value is list
    }

    function isMap(value) {
      return value is map
    }

    function isNull(value) {
      return value == null
    }

    function isNumber(value) {
      return value is number
    }

    function isPath(value) {
      return value is path
    }

    function isPhrase(value) {
      return isString(value) &&
        value.size() <= 40 &&
        value.size() >= 1 &&
        value.upper() == value;
    }

    function isString(value) {
      return value is string
    }

    function isTimestamp(value) {
      return value is timestamp
    }

    function join(joiner, list) {
      return list.join(joiner)
    }

    function join2Args(joiner, a, b) {
      return string(a) + joiner + string(b)
    }

    function join3Args(joiner, a, b, c) {
      return string(a) + joiner + string(b) + joiner + string(c)
    }

    function propsWithSize(properties, propsSize, obj) {
      // Use modulous in order to avoid going out of bounds on selecting from an array
      return slice(0, propsSize, [
        obj.get(properties[0], null),
        obj.get(properties[1 % propsSize], null),
        obj.get(properties[2 % propsSize], null)
      ])
    }

    function props(properties, obj) {
      return propsWithSize(properties, size(properties), obj)
    }

    function size(value) {
      return value.size()
    }

    function slice(start, end, list) {
      return list[start:end]
    }

    function split(char, value) {
      return value.split(char)
    }

    function tail(list) {
      return list[1:list.size()]
    }

    function databasePath() {
      return /databases/$(database)/documents
    }

    function matchesNumeric(value) {
      return value.matches('^[0-9]+$')
    }

    function matchesRFC3339Timestamp(value) {
      return isString(value)
      // TODO BRN": Fix this regex. Firestore doesn't seem to like it
      //return value.matches('^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(([Zz])|([\+|\-]([01][0-9]|2[0-3]):[0-5][0-9]))$')
    }

    function matchesStandardId(value) {
      return value.matches('^[a-zA-Z0-9]{20}$')
    }

    function matchesUuidV4(value) {
      return value.matches('^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$')
    }


    // Current authenticated user methods
    // -----------------------------

    function currentUserIsAuthenticated(auth) {
      return auth != null && auth.uid != null;
    }

    function currentUserIsValid(auth) {
      let user = getUserBefore(auth.uid);
      return user != null && user.data.state == 'valid';
    }

    function currentUserHasAdminRole(auth) {
      let role = getUserRoleBefore(auth.uid);
      return role != null && role.data.role == 'admin';
    }

    function currentUserHasHilRole(auth) {
      let role = getUserRoleBefore(auth.uid);
      return role != null && role.data.role == 'hil';
    }

    function userIdEqualsAuthServiceAccountId(auth, userId) {
      let serviceAccount = getServiceAccountBefore(userId);
      return serviceAccount != null && serviceAccount.id == auth.token.serviceAccountId;
    }

    function authHasServiceAccountIdToken(auth) {
      return auth.token != null && has('serviceAccountId', auth.token);
    }

    function currentUserIsServiceAccount(auth) {
      return currentUserIsAuthenticated(auth) &&
        authHasServiceAccountIdToken(auth) &&
        userIdEqualsAuthServiceAccountId(auth, auth.uid)
    }

    function currentUserOwnsData(auth, data) {
      return auth.uid == data.userId
    }

    function currentUserOwnsResource(auth, resource) {
      return currentUserOwnsData(auth, resource.data)
    }


    // Entity methods
    // -----------------------------

    // NOTE BRN: This is a temporary workaround until the collection names are
    // renamed to be singular
    function pluralize(str) {
      return {
        'AccessToken': 'AccessTokens',
        'Action': 'Actions',
        'ChannelContext': 'ChannelContexts',
        'Conversation': 'Conversations',
        'ConversationMember': 'ConversationMembers',
        'ConversationMessage': 'ConversationMessages',
        'EntityStats': 'EntityStats',
        'Error': 'Errors',
        'Host': 'Hosts',
        'Image': 'Images',
        'Index': 'Indexes',
        'InternalPhoneNumber': 'InternalPhoneNumbers',
        'List':'Lists',
        'ListEntity':'ListEntities',
        'Notification': 'Notifications',
        'NotificationSend': 'NotificationSends',
        'PhoneNumber': 'PhoneNumbers',
        'PhoneNumberClaim': 'PhoneNumberClaims',
        'Preference': 'Preferences',
        'Queue':'Queues',
        'QueueEntity':'QueueEntities',
        'ServiceAccount': 'ServiceAccounts',
        'SMSChallenge': 'SMSChallenges',
        'SMSChannel': 'SMSChannels',
        'SMSMessage': 'SMSMessages',
        'StatsShard': 'StatsShards',
        'Upload': 'Uploads',
        'Url': 'Urls',
        'User': 'Users',
        'UserImage': 'UserImages',
        'UserPhoneNumber': 'UserPhoneNumbers',
        'UserPreferences': 'UserPreferences',
        'UserProfile': 'UserProfiles',
        'UserProfileImage': 'UserProfileImages',
        'UserRole': 'UserRoles',
        'Variable': 'Variables'
      }[string(str)]
    }

    function validateTimestampedData(data) {
      return isTimestamp(data.createdAt) &&
        isTimestamp(data.updatedAt) &&
        (isTimestamp(data.removedAt) || data.removedAt == null)
    }

    function validateTimestamped(resource) {
      return validateTimestampedData(resource.data)
    }

    function validateEntityData(data) {
      return validateTimestampedData(data) &&
        (
          (!has('removedByEntityType', data) || data.removedByEntityType == null) &&
          (!has('removedByEntityId', data) || data.removedByEntityId == null) &&
          dataIsNotRemoved(data)
        ) || (
          entityExistsAfter(
            data.removedByEntityType,
            data.removedByEntityId
          ) &&
          dataIsRemoved(data)
        )
    }

    function validateEntity(resource) {
      return matchesStandardId(resource.id) &&
        validateEntityData(resource.data)
    }

    function entityExistsAfter(entityType, entityId) {
      return existsAfter(/$(databasePath())/$(pluralize(entityType))/$(entityId))
    }

    function entityExistsBefore(entityType, entityId) {
      return exists(/$(databasePath())/$(pluralize(entityType))/$(entityId))
    }

    function entityPathExistsAfter(entityPath) {
      return existsAfter(/$(databasePath())/$(path(entityPath)))
    }

    function entityPathExistsBefore(entityPath) {
      return exists(/$(databasePath())/$(path(entityPath)))
    }

    function getEntityAfter(entityType, entityId) {
      return getAfter(/$(databasePath())/$(pluralize(entityType))/$(entityId))
    }

    function getEntityBefore(entityType, entityId) {
      return get(/$(databasePath())/$(pluralize(entityType))/$(entityId))
    }

    function resourceExists(resource) {
      return resource != null
      // && exists(resource['__name__'])
    }

    function dataIsNotRemoved(data) {
      return data.removedAt == null
    }

    function dataIsRemoved(data) {
      return isTimestamp(data.removedAt)
    }

    function currentUserCanReadPrivateEntity(auth, entity, userId) {
      return (
        (
          currentUserOwnsResource(auth, entity) && dataIsNotRemoved(entity.data)
        ) || (
          currentUserIsAuthenticated(auth) && auth.uid == userId
        ) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }


    function currentUserCanReadProtectedEntity(auth, entity) {
      return (
        (dataIsNotRemoved(entity.data) && resourceExists(entity)) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function currentUserCanReadPublicEntity(auth, entity, allowReadRemoved) {
      return (
        (allowReadRemoved || dataIsNotRemoved(entity.data)) ||
        !resourceExists(entity) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function currentUserCanCreateEntity(auth, entity) {
      return (
        (
          currentUserIsAuthenticated(auth) &&
          currentUserIsValid(auth) &&
          currentUserOwnsResource(auth, entity)
        ) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      );
    }

    function currentUserCanUpdateEntity(auth, entity, allowRestores) {
      return (
        (
          currentUserIsAuthenticated(auth) &&
          currentUserIsValid(auth) &&
          currentUserOwnsResource(auth, entity) &&
          // TODO BRN: A restore should be restricted to only being allowed by
          // the  user that removed the entity
          (allowRestores || dataIsNotRemoved(entity.data))
        ) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }



    // Index methods
    // -----------------------------

    function getIndexAfter(path) {
      return getAfter(/$(databasePath())/Indexes/$(path))
    }

    function buildAndGetIndexAfter(entityType, fieldsKey, fieldsValue) {
      return getIndexAfter(
        /$(pluralize(entityType))/$(fieldsKey)/$(fieldsValue)
      )
    }

    function buildAndGetIndexAfterWithFieldValues(entityType, fields, fieldValues) {
      return buildAndGetIndexAfter(
        entityType,
        join('_', fields),
        join('_', fieldValues)
      )
    }

    function getIndexBefore(path) {
      return get(/$(databasePath())/Indexes/$(path))
    }

    function indexExistsAfter(path) {
      return existsAfter(/$(databasePath())/Indexes/$(path))
    }

    function indexExistsBefore(path) {
      return exists(/$(databasePath())/Indexes/$(path))
    }

    function indexEqualsId(index, id) {
      return index.data.value == id
    }

    function indexedIdMatchesAfterWithEntityData(entityType, entityData, fields, id) {
      return indexEqualsId(
        buildAndGetIndexAfterWithFieldValues(entityType, fields, props(fields, entityData)),
        id
      )
    }

    function indexedIdMatchesAfter(entityType, fields, id) {
      return indexedIdMatchesAfterWithEntityData(
        entityType,
        getEntityAfter(entityType, id).data,
        fields,
        id
      )
    }

    function indexedValuesMatchAfterWithEntityData(entityData, fields, fieldValues) {
      return props(fields, entityData) == fieldValues
    }

    function indexedValueMatchesAfter(entityType, fieldsKey, fieldsValue) {
      return indexedValuesMatchAfterWithEntityData(
        getEntityAfter(
          entityType,
          buildAndGetIndexAfter(entityType, fieldsKey, fieldsValue).data.value
        ).data,
        split('_', fieldsKey),
        split('_', fieldsValue)
      )
    }


    // AccessToken implementation
    // -----------------------------

    function getAccessTokenAfter(id) {
      return getAfter(/$(databasePath())/AccessTokens/$(id))
    }

    function getAccessTokenBefore(id) {
      return get(/$(databasePath())/AccessTokens/$(id))
    }

    function accessTokenExistsAfter(id) {
      return existsAfter(/$(databasePath())/AccessTokens/$(id))
    }

    function accessTokenExistsBefore(id) {
      return exists(/$(databasePath())/AccessTokens/$(id))
    }

    function validateAccessTokenData(data) {
      return matchesUuidV4(data.token) &&
        isBoolean(data.valid) &&
        userExistsAfter(data.userId)
    }

    function validateAccessToken(accessToken) {
      return validateEntity(accessToken) &&
        validateAccessTokenData(accessToken.data)
    }

    function checkReadAccessToken(auth) {
      return currentUserIsServiceAccount(auth)
    }

    function checkCreateAccessToken(auth, id) {
      let accessToken = getAccessTokenAfter(id);
      return accessToken != null && currentUserIsServiceAccount(auth) && validateAccessToken(accessToken);
    }

    function checkUpdateAccessToken(auth, id) {
      let accessToken = getAccessTokenAfter(id);
      return accessToken != null && currentUserIsServiceAccount(auth) && validateAccessToken(accessToken);
    }

    function checkDeleteAccessToken(auth) {
      // Only allow ServiceAccounts to delete
      return currentUserIsServiceAccount(auth)
    }

    match /AccessTokens/{id} {
      allow read: if checkReadAccessToken(request.auth);
      allow create: if checkCreateAccessToken(request.auth, id);
      allow update: if checkUpdateAccessToken(request.auth, id);
      allow delete: if checkDeleteAccessToken(request.auth);
    }


    // Action implementation
    // -----------------------------

    function getActionAfter(type, bucket, id) {
      return getAfter(/$(databasePath())/Actions/$(type)/$(bucket)/$(id))
    }

    function getActionBefore(type, bucket, id) {
      return get(/$(databasePath())/Actions/$(type)/$(bucket)/$(id))
    }

    function actionExistsAfter(type, bucket, id) {
      return existsAfter(/$(databasePath())/Actions/$(type)/$(bucket)/$(id))
    }

    function actionExistsBefore(type, bucket, id) {
      return exists(/$(databasePath())/Actions/$(type)/$(bucket)/$(id))
    }

    function currentUserCausedActionMeta(meta, currentUserId) {
      return meta.causedByEntityType == 'User' &&
        meta.causedByEntityId == currentUserId
    }

    function currentUserCausedAction(auth, action) {
      return currentUserCausedActionMeta(auth, action.data.action.meta)
    }

    function validateEntityChangedPayload(payload) {
      return (
        isString(payload.changeType) &&
        (payload.data == null || isMap(payload.data)) &&
        // TODO BRN: This fails for some reason with a "+1" in the path
        // (entityPathExistsAfter(payload.entityPath) || entityPathExistsBefore(payload.entityPath)) &&
        payload.entityPath.split('/').hasAll([pluralize(payload.entityType), payload.entityId]) &&
        (payload.prevData == null || isMap(payload.prevData))
      )
    }

    function validateUserRegisteredPayload(payload) {
      return (
        isMap(payload.data) &&
        isString(payload.method) &&
        userExistsAfter(payload.userId)
      )
    }

    function validateStorageObjectPayload(payload) {
      return (
        isString(payload.bucket) &&
        (!has('contentLanguage', payload) || isString(payload.contentLanguage)) &&
        isString(payload.contentType) &&
        isString(payload.crc32c) &&
        isString(payload.etag) &&
        isString(payload.generation) &&
        isString(payload.id) &&
        isString(payload.kind) &&
        isString(payload.md5Hash) &&
        isString(payload.mediaLink) &&
        (!has('metadata', payload) || isMap(payload.metadata)) &&
        isInteger(payload.metageneration) &&
        isString(payload.name) &&
        isString(payload.selfLink) &&
        isInteger(payload.size) &&
        isString(payload.storageClass) &&
        isString(payload.timeCreated) &&
        isString(payload.timeStorageClassUpdated) &&
        isString(payload.updated)
      )
    }

    function validateStorageObjectDeletePayload(payload) {
      return validateStorageObjectPayload(payload)
    }

    function validateStorageObjectFinalizePayload(payload) {
      return validateStorageObjectPayload(payload)
    }

    function validateStorageObjectMetadataUpdatePayload(payload) {
      return validateStorageObjectPayload(payload)
    }

    // TODO BRN: Add support for storage actions
    function validateActionPayload(payload, type) {
      return (
        type == 'ENTITY_CHANGED' &&
        validateEntityChangedPayload(payload)
      ) || (
        type == 'auth.UserRegisteredAction' &&
        validateUserRegisteredPayload(payload)
      ) || (
        type == 'STORAGE:OBJECT_DELETE' &&
        validateStorageObjectDeletePayload(payload)
      ) || (
        type == 'STORAGE:OBJECT_FINALIZE' &&
        validateStorageObjectFinalizePayload(payload)
      ) || (
        type == 'STORAGE:OBJECT_METADATA_UPDATE' &&
        validateStorageObjectMetadataUpdatePayload(payload)
      )
    }

    function validateEntityChangedMeta(meta) {
      return (meta.causedByEntityType == null && meta.causedByEntityId == null)
        || entityExistsAfter(meta.causedByEntityType, meta.causedByEntityId)
    }

    function validateActionMeta(meta, type) {
      return (
        type == 'ENTITY_CHANGED' &&
        validateEntityChangedMeta(meta)
      )
    }

    function validateActionDataAction(action, type, id) {
      return action.id == id &&
        action.type == type &&
        isString(action.source) &&
        action.specversion == '0.3-wip' &&
        matchesRFC3339Timestamp(action.time) &&
        isMap(action.payload) &&
        validateActionPayload(action.payload, type) &&
        (!has('meta', action) || validateActionMeta(action.meta, type))
    }

    function validateActionData(data, type, id) {
      return isMap(data.action)
        && validateActionDataAction(data.action, type, id)
    }

    function validateAction(action, type, id) {
      return validateTimestamped(action) &&
        matchesUuidV4(action.id) &&
        validateActionData(action.data, type, id)
    }

    function checkCreateQueueAction(auth, type, id) {
      let action = getActionAfter(type, 'queue', id);
      return (
        currentUserIsServiceAccount(auth) ||
        currentUserHasAdminRole(auth) ||
        currentUserCausedAction(auth, action)
      ) && (
        validateAction(action, type, id) &&
        !actionExistsAfter(type, 'processing', id) &&
        !actionExistsAfter(type, 'resolved', id) &&
        !actionExistsAfter(type, 'rejected', id)
      );
    }

    function checkCreateProcessingAction(auth, type, id, resourceAfter) {
      return currentUserIsServiceAccount(auth) &&
        validateAction(resourceAfter, type, id) &&
        !actionExistsAfter(type, 'queue', id) &&
        !actionExistsAfter(type, 'resolved', id) &&
        !actionExistsAfter(type, 'rejected', id);
    }

    function checkCreateResolvedAction(auth, type, id, resourceAfter) {
      return currentUserIsServiceAccount(auth) &&
        validateAction(resourceAfter, type, id) &&
        !actionExistsAfter(type, 'queue', id) &&
        !actionExistsAfter(type, 'processing', id) &&
        !actionExistsAfter(type, 'rejected', id);
    }

    function checkCreateRejectedAction(auth, type, id, resourceAfter) {
      return currentUserIsServiceAccount(auth) &&
        validateAction(resourceAfter, type, id) &&
        !actionExistsAfter(type, 'queue', id) &&
        !actionExistsAfter(type, 'processing', id) &&
        !actionExistsAfter(type, 'resolved', id);
    }

    match /Actions {
      match /{type}/queue/{id} {
        // NOTE: only allow ServiceAccounts to read and write
        allow read: if currentUserIsServiceAccount(request.auth);
        allow create: if checkCreateQueueAction(request.auth, type, id)
        allow update: if false;
        allow delete: if currentUserIsServiceAccount(request.auth);
      }

      match /{type}/processing/{id} {
        // NOTE: only allow ServiceAccounts to read and write
        allow read: if currentUserIsServiceAccount(request.auth);
        allow create: if checkCreateProcessingAction(request.auth, type, id, getActionAfter(type, 'processing', id))
        allow update: if false;
        allow delete: if currentUserIsServiceAccount(request.auth);
      }

      match /{type}/resolved/{id} {
        // NOTE: only allow ServiceAccounts to read and write
        allow read: if currentUserIsServiceAccount(request.auth);
        allow create: if checkCreateResolvedAction(request.auth, type, id, getActionAfter(type, 'resolved', id))
        allow update: if false;
        allow delete: if currentUserIsServiceAccount(request.auth);
      }

      match /{type}/rejected/{id} {
        // NOTE: only allow ServiceAccounts to read and write
        allow read: if currentUserIsServiceAccount(request.auth);
        allow create: if checkCreateRejectedAction(request.auth, type, id, getActionAfter(type, 'rejected', id))
        allow update: if false;
        allow delete: if currentUserIsServiceAccount(request.auth);
      }
    }


    // ChannelContext implementation
    // -----------------------------

    function channelContextExistsAfter(id) {
      return existsAfter(/$(databasePath())/ChannelContexts/$(id))
    }

    function channelContextExistsBefore(id) {
      return exists(/$(databasePath())/ChannelContexts/$(id))
    }

    function getChannelContextAfter(id) {
      return getAfter(/$(databasePath())/ChannelContexts/$(id))
    }

    function getChannelContextBefore(id) {
      return get(/$(databasePath())/ChannelContexts/$(id))
    }

    function validateChannelContext(resource) {
      return validateEntity(resource) &&
        isMap(resource.data.previous) &&
        smsChannelExistsAfter(resource.data.channelId);
    }

    // NOTE: Only ServiceAccounts can read and write ChannelContexts.
    function checkReadChannelContext(auth) {
      return currentUserIsServiceAccount(auth)
    }

    function checkCreateChannelContext(auth, id) {
      return currentUserIsServiceAccount(auth) &&
        validateChannelContext(getChannelContextAfter(id));
    }

    function checkUpdateChannelContext() {
      // ChannelContexts are immutable. No editing
      return false
    }

    function checkDeleteChannelContext(auth) {
      return currentUserIsServiceAccount(auth);
    }

    match /ChannelContexts/{id} {
      allow read: if checkReadChannelContext(request.auth);
      allow create: if checkCreateChannelContext(request.auth, id);
      allow update: if checkUpdateChannelContext();
      allow delete: if checkDeleteChannelContext(request.auth);
    }


    // Conversation implementation
    // -----------------------------

    function getConversationAfter(id) {
      return getAfter(/$(databasePath())/Conversations/$(id))
    }

    function getConversationBefore(id) {
      return get(/$(databasePath())/Conversations/$(id))
    }

    function conversationExistsAfter(id) {
      return existsAfter(/$(databasePath())/Conversations/$(id))
    }

    function conversationExistsBefore(id) {
      return exists(/$(databasePath())/Conversations/$(id))
    }

    function currentUserCanReadConversation(auth, conversation) {
      return (
        (
          conversation.data.visibility == 'PUBLIC' &&
          dataIsNotRemoved(conversation.data)
        ) || (
          currentUserIsConversationMember(auth, conversation) &&
          dataIsNotRemoved(conversation.data)
        ) ||
        currentUserHasHilRole(auth) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function currentUserCanCreateConversation(auth, conversation) {
      return (
        currentUserWillBeConversationOwner(auth, conversation) ||
        currentUserHasHilRole(auth) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function currentUserCanUpdateConversation(auth, conversationAfter, conversationBefore) {
      return (
        currentUserIsConversationOwnerOrAdmin(auth, conversationBefore) ||
        currentUserHasHilRole(auth) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function validateConversationData(data) {
      return isString(data.visibility)
    }

    function validateConversation(entity) {
      return validateEntity(entity) &&
        validateConversationData(entity.data)
    }

    function checkReadConversation(auth, conversation) {
      return currentUserCanReadConversation(auth, conversation);
    }

    function checkCreateConversation(auth, id) {
      let conversation = getConversationAfter(id);
      return conversation != null &&
        validateConversation(conversation) &&
        currentUserCanCreateConversation(auth, conversation);
    }

    function checkUpdateConversation(auth, id) {
      let conversationAfter = getConversationAfter(id);
      let conversationBefore = getConversationBefore(id);
      return conversationAfter != null &&
        conversationBefore != null &&
        validateConversation(conversationAfter) &&
        currentUserCanUpdateConversation(auth, conversationAfter, conversationBefore);
    }

    function checkDeleteConversation(auth) {
      return currentUserIsServiceAccount(auth);
    }

    match /Conversations/{id} {
      allow read: if checkReadConversation(request.auth, resource);
      allow create: if checkCreateConversation(request.auth, id);
      allow update: if checkUpdateConversation(request.auth, id);
      allow delete: if checkDeleteConversation(request.auth);
    }


    // ConversationMember implementation
    // -----------------------------

    function getConversationMemberAfter(conversationId, userId) {
      return getAfter(/$(databasePath())/Conversations/$(conversationId)/ConversationMembers/$(userId))
    }

    function getConversationMemberBefore(conversationId, userId) {
      return get(/$(databasePath())/Conversations/$(conversationId)/ConversationMembers/$(userId))
    }

    function conversationMemberExistsAfter(conversationId, userId) {
      return existsAfter(/$(databasePath())/Conversations/$(conversationId)/ConversationMembers/$(userId))
    }

    function conversationMemberExistsBefore(conversationId, userId) {
      return exists(/$(databasePath())/Conversations/$(conversationId)/ConversationMembers/$(userId))
    }

    function currentUserIsConversationMember(auth, conversation) {
      let conversationMemberBefore = getConversationMemberBefore(conversation.id, auth.uid);
      return conversationMemberBefore != null && !dataIsRemoved(conversationMemberBefore.data);
    }

    function currentUserIsConversationOwnerOrAdmin(auth, conversation) {
      let conversationMemberBefore = getConversationMemberBefore(conversation.id, auth.uid);
      return conversationMemberBefore != null &&
        !dataIsRemoved(conversationMemberBefore.data) &&
        includes(conversationMemberBefore.data.role, ['ADMIN', 'OWNER']);
    }

    function currentUserWillBeConversationOwner(auth, conversation) {
      let conversationMember = getConversationMemberAfter(conversation.id, auth.uid);
      return conversationMember.data.role == 'OWNER';
    }

    function currentUserCanReadConversationMember(auth, conversation, conversationMember) {
      return (
        currentUserIsConversationMember(auth, conversation) ||
        currentUserHasHilRole(auth) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function currentUserCanCreateConversationMember(auth, conversation, conversationMember) {
      return (
        (
          conversation.data.visibility == 'PUBLIC' &&
          conversationMember.data.role == 'MEMBER' &&
          currentUserOwnsResource(auth, conversationMember)
        ) ||
        currentUserIsConversationOwnerOrAdmin(auth, conversation) ||
        currentUserHasHilRole(auth) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      );
    }

    function currentUserCanUpdateConversationMember(auth, conversation, conversationMemberAfter, conversationMemberBefore) {
      // TODO BRN: need a way to ban users from conversations
      // TODO BRN: Users should only be able to restore their ConversationMember
      // record if the conversation is public and they have not been banned
      return (
        (
          currentUserOwnsResource(auth, conversationMemberAfter) &&
          currentUserOwnsResource(auth, conversationMemberBefore)
        ) ||
        currentUserIsConversationOwnerOrAdmin(auth, conversation) ||
        currentUserHasHilRole(auth) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function validateConversationMemberData(conversation, data) {
      return conversationExistsAfter(data.conversationId) &&
        data.conversationId == conversation.id &&
        userExistsAfter(data.userId) &&
        includes(data.role, [
          'ADMIN',
          'HIL',
          'MEMBER',
          'OWNER'
        ])
    }

    function validateConversationMember(conversation, conversationMember) {
      return validateEntity(conversationMember) &&
        conversationMember.id == conversationMember.data.userId &&
        validateConversationMemberData(conversation, conversationMember.data)
    }

    function checkReadConversationMember(auth, conversationId, userId, conversationMember) {
      let conversation = getConversationAfter(conversationId);
      return currentUserCanReadConversationMember(auth, conversation, conversationMember);
    }

    function checkCreateConversationMember(auth, conversationId, userId) {
      let conversation = getConversationAfter(conversationId);
      let conversationMember = getConversationMemberAfter(conversationId, userId);
      return conversation != null &&
        conversationMember != null &&
        validateConversationMember(conversation, conversationMember) &&
        currentUserCanCreateConversationMember(auth, conversation, conversationMember);
    }

    function checkUpdateConversationMember(auth, conversationId, userId) {
      let conversation = getConversationAfter(conversationId);
      let conversationMemberAfter = getConversationMemberAfter(conversationId, userId);
      let conversationMemberBefore = getConversationMemberBefore(conversationId, userId);
      return conversation != null &&
        conversationMemberAfter != null &&
        conversationMemberBefore != null &&
        validateConversationMember(conversation, conversationMemberAfter) &&
        currentUserCanUpdateConversationMember(auth, conversation, conversationMemberAfter, conversationMemberBefore);
    }

    function checkDeleteConversationMember(auth) {
      // Only allow ServiceAccounts to delete
      return currentUserIsServiceAccount(auth)
    }

    match /Conversations/{conversationId}/ConversationMembers/{userId} {
      allow read: if checkReadConversationMember(request.auth, conversationId, userId, resource);
      allow create: if checkCreateConversationMember(request.auth, conversationId, userId);
      allow update: if checkUpdateConversationMember(request.auth, conversationId, userId);
      allow delete: if checkDeleteConversationMember(request.auth);
    }


    // ConversationMessage implementation
    // -----------------------------

    function getConversationMessageAfter(conversationId, messageId) {
      return getAfter(/$(databasePath())/Conversations/$(conversationId)/ConversationMessages/$(messageId))
    }

    function getConversationMessageBefore(conversationId, messageId) {
      return get(/$(databasePath())/Conversations/$(conversationId)/ConversationMessages/$(messageId))
    }

    function conversationMessageExistsAfter(conversationId, messageId) {
      return existsAfter(/$(databasePath())/Conversations/$(conversationId)/ConversationMessages/$(messageId))
    }

    function conversationMessageExistsBefore(conversationId, messageId) {
      return exists(/$(databasePath())/Conversations/$(conversationId)/ConversationMessages/$(messageId))
    }

    function currentUserCanReadConversationMessage(auth, conversation, conversationMessage) {
      return (
        (
          conversation.id == conversationMessage.data.conversationId &&
          currentUserIsConversationMember(auth, conversation)
        ) ||
        currentUserHasHilRole(auth) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function currentUserCanCreateConversationMessage(auth, conversation, conversationMessage) {
      return (
        (
          currentUserIsConversationMember(auth, conversation)  &&
          currentUserOwnsResource(auth, conversationMessage)
        ) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function currentUserCanUpdateConversationMessage(auth, conversation, conversationMessageAfter, conversationMessageBefore) {
      // TODO BRN: need a way to separate removing a message vs updating the
      // of the message. Admins and HILs should be able to remove messages but
      // not be able to update the content of another user's message
      return (
        (
          currentUserOwnsResource(auth, conversationMessageAfter) &&
          currentUserOwnsResource(auth, conversationMessageBefore)
        ) ||
        currentUserIsConversationOwnerOrAdmin(auth, conversation) ||
        currentUserHasHilRole(auth) ||
        currentUserHasAdminRole(auth) ||
        currentUserIsServiceAccount(auth)
      )
    }

    function validateConversationMessageData(conversation, data) {
      return conversationExistsAfter(data.conversationId) &&
        userExistsAfter(data.userId) &&
        data.conversationId == conversation.id &&
        (data.attachments == null || isList(data.attachments)) &&
        (data.editedAt == null || isTimestamp(data.editedAt)) &&
        (data.sentAt == null || isTimestamp(data.sentAt)) &&
        isString(data.type);
    }

    function validateConversationMessage(conversation, conversationMessage) {
      return validateEntity(conversationMessage) &&
        validateConversationMessageData(conversation, conversationMessage.data)
    }

    function checkReadConversationMessage(auth, conversationId, conversationMessage) {
      let conversation = getConversationAfter(conversationId);
      return currentUserCanReadConversationMessage(auth, conversation, conversationMessage);
    }

    function checkCreateConversationMessage(auth, conversationId, messageId) {
      let conversation = getConversationAfter(conversationId);
      let conversationMessage = getConversationMessageAfter(conversationId, messageId);
      return conversation != null &&
        conversationMessage != null &&
        validateConversationMessage(conversation, conversationMessage) &&
        currentUserCanCreateConversationMessage(auth, conversation, conversationMessage);
    }

    function checkUpdateConversationMessage(auth, conversationId, messageId) {
      let conversation = getConversationAfter(conversationId);
      let conversationMessageAfter = getConversationMessageAfter(conversationId, messageId);
      let conversationMessageBefore = getConversationMessageBefore(conversationId, messageId);
      return conversation != null &&
        conversationMessageAfter != null &&
        conversationMessageBefore != null &&
        validateConversationMessage(conversation, conversationMessageAfter) &&
        currentUserCanUpdateConversationMessage(auth, conversation, conversationMessageAfter, conversationMessageBefore);
    }

    function checkDeleteConversationMessage(auth) {
      // Only allow ServiceAccounts to delete
      return currentUserIsServiceAccount(auth)
    }

    match /Conversations/{conversationId}/ConversationMessages/{messageId} {
      allow read: if checkReadConversationMessage(request.auth, conversationId, resource);
      allow create: if checkCreateConversationMessage(request.auth, conversationId, messageId);
      allow update: if checkUpdateConversationMessage(request.auth, conversationId, messageId);
      allow delete: if checkDeleteConversationMessage(request.auth);
    }


    // EntityStats implementation
    // -----------------------------

    function getEntityStatsAfter(id) {
      return getAfter(/$(databasePath())/EntityStats/$(id))
    }

    function getEntityStatsBefore(id) {
      return get(/$(databasePath())/EntityStats/$(id))
    }

    function entityStatsExistsAfter(id) {
      return existsAfter(/$(databasePath())/EntityStats/$(id))
    }

    function entityStatsExistsBefore(id) {
      return exists(/$(databasePath())/EntityStats/$(id))
    }

    function validateEntityStatsData(data) {
      return isString(data.entityType) &&
        isString(data.entityId) &&
        // entityExistsAfter(data.entityType, data.entityId)
        isNumber(data.numberShards)
    }

    function validateEntityStats(resource) {
      return validateEntity(resource) &&
        validateEntityStatsData(resource.data)
    }

    match /EntityStats/{id} {
      allow read: if currentUserCanReadPublicEntity(request.auth, resource, false);

      allow create: if currentUserIsServiceAccount(request.auth) &&
        validateEntityStats(getEntityStatsAfter(id)) &&
        indexedIdMatchesAfter('EntityStats', ['entityType', 'entityId'], id);

      allow update: if currentUserIsServiceAccount(request.auth) &&
        validateEntityStats(getEntityStatsAfter(id)) &&
        indexedIdMatchesAfter('EntityStats', ['entityType', 'entityId'], id);

      allow delete: if currentUserIsServiceAccount(request.auth);
    }

    match /Indexes/EntityStats/entityType_entityId/{entityType_entityId} {
      allow read: if currentUserIsServiceAccount(request.auth);
      allow create: if currentUserIsServiceAccount(request.auth) &&
        indexedValueMatchesAfter('EntityStats', 'entityType_entityId', entityType_entityId);

      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // EntityStats/{id}/StatsShards implementation
    // -----------------------------

    function getEntityStatsShardAfter(id, index) {
      return getAfter(/$(databasePath())/EntityStats/$(id)/StatsShards/$(index))
    }

    function getEntityStatsShardBefore(id, index) {
      return get(/$(databasePath())/EntityStats/$(id)/StatsShards/$(index))
    }

    function entityStatsShardExistsAfter(id, index) {
      return existsAfter(/$(databasePath())/EntityStats/$(id)/StatsShards/$(index))
    }

    function entityStatsShardExistsBefore(id, index) {
      return exists(/$(databasePath())/EntityStats/$(id)/StatsShards/$(index))
    }

    function validateEntityStatsShardData(data) {
      return isMap(data.data)
        && isNumber(data.index)
    }

    function validateEntityStatsShard(entity) {
      return matchesNumeric(entity.id) &&
        validateEntityData(entity.data) &&
        validateEntityStatsShardData(entity.data)
    }

    match /EntityStats/{id}/StatsShards/{index} {
      allow read: if currentUserCanReadPublicEntity(request.auth, resource, false);

      allow create: if currentUserIsServiceAccount(request.auth) &&
        validateEntityStatsShard(getEntityStatsShardAfter(id, index));

      allow update: if currentUserIsServiceAccount(request.auth) &&
        validateEntityStatsShard(getEntityStatsShardAfter(id, index));

      allow delete: if currentUserIsServiceAccount(request.auth);
    }

    // Error implementation
    // -----------------------------

    function getErrorAfter(id) {
      return getAfter(/$(databasePath())/Errors/$(id))
    }

    function getErrorBefore(id) {
      return get(/$(databasePath())/Errors/$(id))
    }

    function errorExistsAfter(id) {
      return existsAfter(/$(databasePath())/Errors/$(id))
    }

    function errorExistsBefore(id) {
      return exists(/$(databasePath())/Errors/$(id))
    }

    function validateErrorData(data) {
      return (isString(data.code) || data.code == null) &&
        isString(data.message) &&
        isString(data.stack) &&
        isString(data.source)
    }

    function validateError(entity) {
      return validateEntity(entity) &&
        validateErrorData(entity.data)
    }

    function checkReadError(auth) {
      return currentUserIsServiceAccount(auth)
    }

    function checkCreateError(auth, resourceAfter) {
      return currentUserIsServiceAccount(auth) &&
        validateError(resourceAfter)
    }

    function checkUpdateError(auth, resourceAfter) {
      return currentUserIsServiceAccount(auth) &&
        validateError(resourceAfter)
    }

    function checkDeleteError(auth) {
      return currentUserIsServiceAccount(auth);
    }

    match /Errors/{id} {
      allow read: if checkReadError(request.auth);
      allow create: if checkCreateError(request.auth, getErrorAfter(id));
      allow update: if checkUpdateError(request.auth, getErrorAfter(id));
      allow delete: if checkDeleteError(request.auth);
    }


    // Host implementation
    // -----------------------------

    function getHostAfter(id) {
      return getAfter(/$(databasePath())/Hosts/$(id))
    }

    function getHostBefore(id) {
      return get(/$(databasePath())/Hosts/$(id))
    }

    function hostExistsAfter(id) {
      return existsAfter(/$(databasePath())/Hosts/$(id))
    }

    function hostExistsBefore(id) {
      return exists(/$(databasePath())/Hosts/$(id))
    }

    function validateHostData(data) {
      // TODO BRN: replace this with more accurate checks
      return isString(data.domain) &&
        (isString(data.subDomain) || isNull(data.subDomain)) &&
        isString(data.topLevelDomain)
    }

    function validateHost(entity) {
      return validateEntity(entity) &&
        validateHostData(entity.data)
    }

    function checkReadHost(auth) {
      return currentUserIsServiceAccount(auth)
    }

    function checkCreateHost(auth, resourceAfter) {
      return currentUserIsServiceAccount(auth) &&
        validateHost(resourceAfter)
    }

    function checkUpdateHost(auth, resourceAfter) {
      return currentUserIsServiceAccount(auth) &&
        validateHost(resourceAfter)
    }

    function checkDeleteHost(auth) {
      return currentUserIsServiceAccount(auth);
    }

    match /Hosts/{id} {
      allow read: if checkReadHost(request.auth);
      allow create: if checkCreateHost(request.auth ,getHostAfter(id));
      allow update: if checkUpdateHost(request.auth, getHostAfter(id));
      allow delete: if checkDeleteHost(request.auth);
    }


    // Image implementation
    // -----------------------------

    function getImageAfter(id) {
      return getAfter(/$(databasePath())/Images/$(id))
    }

    function getImageBefore(id) {
      return get(/$(databasePath())/Images/$(id))
    }

    function imageExistsAfter(id) {
      return existsAfter(/$(databasePath())/Images/$(id))
    }

    function imageExistsBefore(id) {
      return exists(/$(databasePath())/Images/$(id))
    }

    function validateImageData(data) {
      return isImageContentType(data.contentType) &&
        isHex(data.hash) &&
        isNumber(data.height) &&
        isNumber(data.length) &&
        (isString(data.path) || !has('path', data)) &&
        isString(data.storageBucket) &&
        isNumber(data.width)
    }

    function validateImage(resource) {
      return validateEntity(resource) &&
        validateImageData(resource.data)
    }

    match /Images/{id} {
      // NOTE: Only ServiceAccounts can read and write Images.
      // This is because images are returned by a pass through in firebase
      // hosting. So only ServiceAccounts actually need to read or write them
      allow read: if currentUserIsServiceAccount(request.auth);
      allow create: if currentUserIsServiceAccount(request.auth) &&
        validateImage(getImageAfter(id));

      allow update: if currentUserIsServiceAccount(request.auth) &&
        validateImage(getImageAfter(id));

      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // InternalPhoneNumber implementation
    // -----------------------------

    function getInternalPhoneNumberAfter(phoneNumberId) {
      return getAfter(/$(databasePath())/InternalPhoneNumbers/$(phoneNumberId))
    }

    function getInternalPhoneNumberBefore(phoneNumberId) {
      return get(/$(databasePath())/InternalPhoneNumbers/$(phoneNumberId))
    }

    function internalPhoneNumberExistsAfter(phoneNumberId) {
      return existsAfter(/$(databasePath())/InternalPhoneNumbers/$(phoneNumberId))
    }

    function internalPhoneNumberExistsBefore(phoneNumberId) {
      return exists(/$(databasePath())/InternalPhoneNumbers/$(phoneNumberId))
    }

    function validateInternalPhoneNumber(resource) {
      return validateEntity(resource) &&
        phoneNumberExistsAfter(resource.data.phoneNumberId) &&
        getPhoneNumberAfter(resource.data.phoneNumberId).data.type == 'internal'
    }

    match /InternalPhoneNumbers/{phoneNumberId} {
      allow read: if currentUserCanReadProtectedEntity(request.auth ,resource);

      allow create: if validateInternalPhoneNumber(getInternalPhoneNumberAfter(phoneNumberId)) &&
        currentUserIsServiceAccount(request.auth);
      allow update: if false;
      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // List implementation
    // -----------------------------

    function getListAfter(id) {
      return getAfter(/$(databasePath())/Lists/$(id))
    }

    function getListBefore(id) {
      return get(/$(databasePath())/Lists/$(id))
    }

    function listExistsAfter(id) {
      return existsAfter(/$(databasePath())/Lists/$(id))
    }

    function listExistsBefore(id) {
      return exists(/$(databasePath())/Lists/$(id))
    }

    function validateListData(data) {
      return (
        (isNull(data.parentEntityId) && isNull(data.parentEntityType)) ||
        entityExistsAfter(data.parentEntityType, data.parentEntityId)
      )
    }

    function validateList(resource) {
      return validateEntity(resource) &&
        validateListData(resource.data)
    }

    function checkReadList(auth, resource) {
      return currentUserCanReadPublicEntity(auth, resource, false)
    }

    function checkCreateList(auth, id) {
      let list = getListAfter(id);
      return list != null && validateList(list) && currentUserIsServiceAccount(auth)
    }

    function checkUpdateList(auth, id) {
      let list = getListAfter(id);
      return list != null && validateList(list) && currentUserIsServiceAccount(auth)
    }

    function checkDeleteList(auth) {
      // Only allow ServiceAccounts to delete
      return currentUserIsServiceAccount(auth)
    }

    match /Lists/{id} {
      allow read: if checkReadList(request.auth, resource);
      allow create: if checkCreateList(request.auth, id);
      allow update: if checkUpdateList(request.auth, id);
      allow delete: if checkDeleteList(request.auth);
    }

    // ListEntity implementation
    // -----------------------------

    function getListEntityAfter(id) {
      return getAfter(/$(databasePath())/ListEntities/$(id))
    }

    function getListEntityBefore(id) {
      return get(/$(databasePath())/ListEntities/$(id))
    }

    function listEntityExistsAfter(id) {
      return existsAfter(/$(databasePath())/ListEntities/$(id))
    }

    function EntityExistsBefore(id) {
      return exists(/$(databasePath())/ListEntities/$(id))
    }

    function validateListEntityData(data) {
      return listExistsAfter(data.listId) &&
        (isIndex(data.index)) &&
        entityExistsAfter(data.entityType, data.entityId)
    }

    function validateListEntity(resource) {
      return validateEntity(resource) &&
        validateListEntityData(resource.data)
    }

    function checkReadListEntity(auth, resource) {
      return currentUserCanReadPublicEntity(auth, resource, false)
    }

    function checkCreateListEntity(auth, id) {
      let queueEntity = getListEntityAfter(id);
      return queueEntity != null && validateListEntity(queueEntity)
        && indexedIdMatchesAfter('ListEntity', ['listId', 'index'], id)
        && currentUserIsServiceAccount(auth);
    }

    function checkUpdateListEntity(auth, id) {
      let queueEntity = getListEntityAfter(id);
      return queueEntity != null && validateListEntity(queueEntity)
        && indexedIdMatchesAfter('ListEntity', ['listId', 'index'], id)
        && currentUserIsServiceAccount(auth);
    }

    function checkDeleteListEntity(auth) {
      // Only allow ServiceAccounts to delete
      return currentUserIsServiceAccount(auth)
    }

    match /ListEntities/{id} {
      allow read: if checkReadListEntity(request.auth, resource);
      allow create: if checkCreateListEntity(request.auth, id);
      allow update: if checkUpdateListEntity(request.auth, id);
      allow delete: if checkDeleteListEntity(request.auth);
    }

    match /Indexes/ListEntities/listId_index/{listId_index} {
      allow read: if true;
      allow create: if indexedValueMatchesAfter('ListEntity', 'listId_index', listId_index);
      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // Notification implementation
    // -----------------------------

    function getNotificationAfter(id) {
      return getAfter(/$(databasePath())/Notifications/$(id))
    }

    function getNotificationBefore(id) {
      return get(/$(databasePath())/Notifications/$(id))
    }

    function sendExistsAfter(id) {
      return existsAfter(/$(databasePath())/Notifications/$(id))
    }

    function sendExistsBefore(id) {
      return exists(/$(databasePath())/Notifications/$(id))
    }

    function validateNotificationData(data) {
      return userExistsAfter(data.userId) &&
        (isTimestamp(data.readAt) || isNull(data.readAt)) &&
        isString(data.type) &&
        (isMap(data.meta) || isNull(data.meta))
    }

    function validateNotification(resource) {
      return validateEntity(resource) &&
        validateNotificationData(resource.data)
    }

    function checkReadNotification(auth, resource) {
      return currentUserCanReadPrivateEntity(auth, resource, resource.userId)
    }

    function checkCreateNotification(auth, resourceAfter) {
      return validateNotification(resourceAfter) &&
        currentUserIsServiceAccount(auth)
    }

    function checkUpdateNotification(auth, resourceAfter) {
      return validateNotification(resourceAfter) &&
        currentUserCanUpdateEntity(auth, resourceAfter, false)
    }

    function checkDeleteNotification(auth) {
      return currentUserIsServiceAccount(auth);
    }

    match /Notifications/{id} {
      allow read: if checkReadNotification(request.auth, resource);
      allow create: if checkCreateNotification(request.auth, getNotificationAfter(id));
      allow update: if checkUpdateNotification(request.auth, getNotificationAfter(id));
      allow delete: if checkDeleteNotification(request.auth);
    }

    // Notifications/{id}/NotificationSends implementation
    // -----------------------------

    function getNotificationSendAfter(sendId, sendSendId) {
      return getAfter(/$(databasePath())/Notifications/$(sendId)/NotificationSends/$(sendSendId))
    }

    function getNotificationSendBefore(sendId, sendSendId) {
      return get(/$(databasePath())/Notifications/$(sendId)/NotificationSends/$(sendSendId))
    }

    function sendSendExistsAfter(sendId, sendSendId) {
      return existsAfter(/$(databasePath())/Notifications/$(sendId)/NotificationSends/$(sendSendId))
    }

    function sendSendExistsBefore(sendId, sendSendId) {
      return exists(/$(databasePath())/Notifications/$(sendId)/NotificationSends/$(sendSendId))
    }

    function validateNotificationSendData(data, send) {
      return isMap(data.channels) &&
        (errorExistsAfter(data.errorId) || data.errorId == null) &&
        data.sendId == send.id &&
        (isMap(data.sentAt) || data.sentAt == null) &&
        includes(data.state, [
          'ABORTED',
          'COMPLETED',
          'ERROR',
          'SENDING'
        ])
    }

    function validateNotificationSend(resource, sendAfter) {
      return validateEntity(resource) &&
        validateNotificationSendData(resource.data, sendAfter)
    }

    function checkReadNotificationSend(auth, resource) {
      return currentUserCanReadPrivateEntity(auth, resource, resource.userId)
    }

    function checkCreateNotificationSend(auth, sendAfter, sendSendAfter) {
      return currentUserIsServiceAccount(auth) &&
        validateNotificationSend(sendSendAfter, sendAfter)
    }

    function checkUpdateNotificationSend(auth, sendBefore, sendSendAfter) {
      return currentUserIsServiceAccount(auth) &&
        validateNotificationSend(sendSendAfter, sendBefore)
    }

    function checkDeleteNotificationSend(auth) {
      return currentUserIsServiceAccount(auth)
    }

    match /Notifications/{sendId}/NotificationSends/{sendSendId} {
      allow read: if checkReadNotificationSend(request.auth, resource);
      allow create: if checkCreateNotificationSend(
        request.auth,
        getNotificationAfter(sendId),
        getNotificationSendAfter(sendId, sendSendId)
      );
      allow update: if checkUpdateNotificationSend(
        request.auth,
        getNotificationBefore(sendId),
        getNotificationSendAfter(sendId, sendSendId)
      );
      allow delete: if checkDeleteNotificationSend(request.auth);
    }

    match /{somePath=**}/NotificationSends/{sendSendId} {
      allow read: if checkReadNotificationSend(request.auth, resource);
    }


    // PhoneNumber implementation
    // -----------------------------

    function getPhoneNumberAfter(id) {
      return getAfter(/$(databasePath())/PhoneNumbers/$(id))
    }

    function getPhoneNumberBefore(id) {
      return get(/$(databasePath())/PhoneNumbers/$(id))
    }

    function phoneNumberExistsAfter(id) {
      return existsAfter(/$(databasePath())/PhoneNumbers/$(id))
    }

    function phoneNumberExistsBefore(id) {
      return exists(/$(databasePath())/PhoneNumbers/$(id))
    }

    function validatePhoneNumber(resource) {
      return validateEntity(resource) &&
        isHex(resource.data.hash) &&
        isString(resource.data.phoneNumber) &&
        (
          (resource.data.type == 'internal' &&
            validateInternalPhoneNumberType(resource)) ||
          (resource.data.type == 'unclaimed' &&
            validateUnclaimedPhoneNumberType(resource)) ||
          (resource.data.type == 'user' &&
            validateUserPhoneNumberType(resource))
        )
    }

    function validateInternalPhoneNumberType(resource) {
      return internalPhoneNumberExistsAfter(resource.id)
    }

    function validateUnclaimedPhoneNumberType(resource) {
      return indexExistsAfter(/PhoneNumberClaims/phoneNumberId/$(resource.id))
    }

    function validateUserPhoneNumberType(resource) {
      return userPhoneNumberExistsAfter(resource.id)
    }

    match /PhoneNumbers/{id} {
      // Only allow ServiceAccounts to read
      allow read: if currentUserIsServiceAccount(request.auth);

      // Anyone can add phone numbers
      allow create: if
        validatePhoneNumber(getPhoneNumberAfter(id)) &&
        indexedIdMatchesAfter('PhoneNumber', ['hash'], id) &&
        (
          currentUserIsServiceAccount(request.auth) ||
          // Only allow users to create unclaimed phone numbers
          getPhoneNumberAfter(id).data.type == 'unclaimed'
        );

      // ServiceAccounts can update phone numbers
      allow update: if
        validatePhoneNumber(getPhoneNumberAfter(id)) &&
        indexedIdMatchesAfter('PhoneNumber', ['hash'], id) &&
        currentUserIsServiceAccount(request.auth);

      allow delete: if currentUserIsServiceAccount(request.auth);
    }

    match /Indexes/PhoneNumbers/hash/{hash} {
      allow read: if true;
      allow create: if indexedValueMatchesAfter('PhoneNumber', 'hash', hash);
      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // PhoneNumberClaim implementation
    // -----------------------------

    function getPhoneNumberClaimAfter(id) {
      return getAfter(/$(databasePath())/PhoneNumberClaims/$(id))
    }

    function getPhoneNumberClaimBefore(id) {
      return get(/$(databasePath())/PhoneNumberClaims/$(id))
    }

    function phoneNumberClaimExistsAfter(id) {
      return existsAfter(/$(databasePath())/PhoneNumberClaims/$(id))
    }

    function phoneNumberClaimExistsBefore(id) {
      return exists(/$(databasePath())/PhoneNumberClaims/$(id))
    }

    function validatePhoneNumberClaim(resource) {
      return validateEntity(resource) &&
        userExistsAfter(resource.data.userId) &&
        phoneNumberExistsAfter(resource.data.phoneNumberId) &&
        getPhoneNumberAfter(resource.data.phoneNumberId).data.type == 'unclaimed'
    }

    match /PhoneNumberClaims/{id} {
      // Allow everyone to lookup user ids by phone number claims
      allow read: if currentUserCanReadProtectedEntity(request.auth, resource);

      // Anyone can add phone number claims if they do not exist in
      // UserPhoneNumbers or InternalPhoneNumbers
      allow create: if
        validatePhoneNumberClaim(getPhoneNumberClaimAfter(id)) &&
        !userPhoneNumberExistsAfter(getPhoneNumberClaimAfter(id).data.phoneNumberId) &&
        indexedIdMatchesAfter('PhoneNumberClaim', ['phoneNumberId'], id);

      // ServiceAccounts can update PhoneNumberClaims
      allow update: if currentUserIsServiceAccount(request.auth);

      // Only ServiceAccounts can delete phone number claims
      allow delete: if currentUserIsServiceAccount(request.auth);
    }

    match /Indexes/PhoneNumberClaims/phoneNumberId/{phoneNumberId} {
      allow read: if currentUserIsServiceAccount(request.auth);
      allow create: if indexedValueMatchesAfter(
        'PhoneNumberClaim',
        'phoneNumberId',
        phoneNumberId
      );

      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // Preferences implementation
    // -----------------------------

    function getPreferenceAfter(id, key) {
      return getAfter(/$(databasePath())/UserPreferences/$(id)/Preferences/$(key))
    }

    function getPreferenceBefore(id, key) {
      return get(/$(databasePath())/UserPreferences/$(id)/Preferences/$(key))
    }

    function preferenceExistsAfter(id, key) {
      return existsAfter(/$(databasePath())/UserPreferences/$(id)/Preferences/$(key))
    }

    function preferenceExistsBefore(id, key) {
      return exists(/$(databasePath())/UserPreferences/$(id)/Preferences/$(key))
    }

    function validatePreferenceData(data) {
      return userPreferencesExistsAfter(data.userPreferencesId) &&
        isString(data.key) &&
        has('value', data)
    }

    function validatePreference(entity) {
      return entity.data.key == entity.id &&
        validateEntityData(entity.data) &&
        validatePreferenceData(entity.data)
    }

    function checkReadPreference(auth, resource) {
      return currentUserCanReadPublicEntity(auth, resource, false)
    }

    function checkCreatePreference(auth, id, key) {
      let preference = getPreferenceAfter(id, key);
      return preference != null && validatePreference(preference) &&
        currentUserCanCreateUserPreferences(auth, preference.userPreferencesId)
    }

    function checkUpdatePreference(auth, id, key) {
      let preference = getPreferenceAfter(id, key);
      return preference != null && validatePreference(preference) &&
        currentUserCanUpdateUserPreferences(auth, preference.userPreferencesId, true)
    }

    function checkDeletePreference(auth) {
      // Only allow ServiceAccounts to delete
      return currentUserIsServiceAccount(auth)
    }

    match /UserPreferences/{id}/Preferences/{key} {
      allow read: if checkReadPreference(request.auth, resource);
      allow create: if checkCreatePreference(request.auth, id, key);
      allow update: if checkUpdatePreference(request.auth, id, key);
      allow delete: if checkDeletePreference(request.auth);
    }


    // Queue implementation
    // -----------------------------

    function getQueueAfter(id) {
      return getAfter(/$(databasePath())/Queues/$(id))
    }

    function getQueueBefore(id) {
      return get(/$(databasePath())/Queues/$(id))
    }

    function queueExistsAfter(id) {
      return existsAfter(/$(databasePath())/Queues/$(id))
    }

    function queueExistsBefore(id) {
      return exists(/$(databasePath())/Queues/$(id))
    }

    function validateQueueData(data) {
      return (
        (isNull(data.parentEntityId) && isNull(data.parentEntityType)) ||
        entityExistsAfter(data.parentEtityType, data.parentEntityId) &&
        isIndex(data.headIndex) &&
        isInteger(data.length) &&
        isInteger(data.tailIndex)
      )
    }

    function validateQueue(resource) {
      return validateEntity(resource) &&
        validateQueueData(resource.data)
    }

    function checkReadQueue(auth, resource) {
      return currentUserCanReadPublicEntity(auth, resource, false)
    }

    function checkCreateQueue(auth, id) {
      let queue = getQueueAfter(id);
      return queue != null && validateQueue(queue)
        && currentUserIsServiceAccount(auth);
    }

    function checkUpdateQueue(auth, id) {
      let queue = getQueueAfter(id);
      return queue != null && validateQueue(queue)
        && currentUserIsServiceAccount(auth);
    }

    function checkDeleteQueue(auth) {
      // Only allow ServiceAccounts to delete
      return currentUserIsServiceAccount(auth)
    }

    function currentUserOwnsQueue(auth, queueId) {
      return currentUserIsServiceAccount(auth) || currentUserHasAdminRole(auth) ||
        (getQueueAfter(queueId).userId == auth.uid)
    }

    match /Queues/{id} {
      allow read: if checkReadQueue(request.auth, resource);
      allow create: if checkCreateQueue(request.auth, id);
      allow update: if checkUpdateQueue(request.auth, id);
      allow delete: if checkDeleteQueue(request.auth);
    }

    // QueueEntity implementation
    // -----------------------------

    function getQueueEntityAfter(id, index) {
      return getAfter(/$(databasePath())/Queues/$(id)/QueueEntities/$(index))
    }

    function getQueueEntityBefore(id, index) {
      return get(/$(databasePath())/Queues/$(id)/QueueEntities/$(index))
    }

    function queueEntityExistsAfter(id, index) {
      return existsAfter(/$(databasePath())/Queues/$(id)/QueueEntities/$(index))
    }

    function queueEntityExistsBefore(id, index) {
      return exists(/$(databasePath())/Queues/$(id)/QueueEntities/$(index))
    }

    function validateQueueEntityData(data) {
      return queueExistsAfter(data.queueId) &&
        isInteger(data.index) &&
        entityExistsAfter(data.entityType, data.entityId)
    }

    function validateQueueEntity(entity) {
      return matchesNumeric(entity.id) &&
        validateEntityData(entity.data) &&
        validateQueueEntityData(entity.data)
    }

    function checkReadQueueEntity(auth, resource) {
      return currentUserCanReadPublicEntity(auth, resource, false)
    }

    function checkCreateQueueEntity(auth, id, index) {
      let queueEntity = getQueueEntityAfter(id, index);
      return queueEntity != null && validateQueueEntity(queueEntity) &&
        currentUserOwnsQueue(auth, queueEntity.queueId)
    }

    function checkUpdateQueueEntity(auth, id, index) {
      let queueEntity = getQueueEntityAfter(id, index);
      return queueEntity != null && validateQueueEntity(queueEntity) &&
        currentUserOwnsQueue(auth, queueEntity.queueId)
    }

    function checkDeleteQueueEntity(auth) {
      // Only allow ServiceAccounts to delete
      return currentUserIsServiceAccount(auth)
    }

    match /Queues/{id}/QueueEntities/{index} {
      allow read: if checkReadQueueEntity(request.auth, resource);
      allow create: if checkCreateQueueEntity(request.auth, id, index);
      allow update: if checkUpdateQueueEntity(request.auth, id, index);
      allow delete: if checkDeleteQueueEntity(request.auth);
    }


    // ServiceAccount implementation
    // -----------------------------

    function getServiceAccountAfter(id) {
      return getAfter(/$(databasePath())/ServiceAccounts/$(id))
    }

    function getServiceAccountBefore(id) {
      return get(/$(databasePath())/ServiceAccounts/$(id))
    }

    function serviceAccountExistsAfter(id) {
      return existsAfter(/$(databasePath())/ServiceAccounts/$(id))
    }

    function serviceAccountExistsBefore(id) {
      return exists(/$(databasePath())/ServiceAccounts/$(id))
    }

    function validateServiceAccount(resource) {
      return matchesUuidV4(resource.id) &&
        isString(resource.data.name) &&
        resource.data.uid == resource.id
    }

    match /ServiceAccounts/{id} {
      // Only firebase admins can create ServiceAccounts
      allow read: if false;
      allow write: if false;
    }


    // SMSChallenge implementation
    // -----------------------------

    function getSMSChallengeAfter(id) {
      return getAfter(/$(databasePath())/SMSChallenges/$(id))
    }

    function getSMSChallengeBefore(id) {
      return get(/$(databasePath())/SMSChallenges/$(id))
    }

    function smsChallengeExistsAfter(id) {
      return existsAfter(/$(databasePath())/SMSChallenges/$(id))
    }

    function smsChallengeExistsBefore(id) {
      return exists(/$(databasePath())/SMSChallenges/$(id))
    }

    function validateSMSChallenge(resource) {
      return validateEntity(resource) &&
        isString(resource.data.code) &&
        isString(resource.data.expiresIn) &&
        phoneNumberExistsAfter(resource.data.phoneNumberId) &&
        smsChannelExistsAfter(resource.data.smsChannelId) &&
        (isTimestamp(resource.data.usedAt) || !has('usedAt', resource.data)) &&
        isBoolean(resource.data.valid)
    }

    match /SMSChallenges/{id} {
      // NOTE: only allow ServiceAccounts to read and write
      allow read: if currentUserIsServiceAccount(request.auth);
      allow create: if currentUserIsServiceAccount(request.auth) &&
        validateSMSChallenge(getSMSChallengeAfter(id));
      allow update: if currentUserIsServiceAccount(request.auth) &&
        validateSMSChallenge(resource);
      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // SMSChannel implementation
    // -----------------------------

    function getSMSChannelAfter(id) {
      return getAfter(/$(databasePath())/SMSChannels/$(id))
    }

    function getSMSChannelBefore(id) {
      return get(/$(databasePath())/SMSChannels/$(id))
    }

    function smsChannelExistsAfter(id) {
      return existsAfter(/$(databasePath())/SMSChannels/$(id))
    }

    function smsChannelExistsBefore(id) {
      return exists(/$(databasePath())/SMSChannels/$(id))
    }

    function validateSMSChannel(resource) {
      return validateEntity(resource) &&
        internalPhoneNumberExistsAfter(resource.data.internalPhoneNumberId) &&
        phoneNumberExistsAfter(resource.data.userPhoneNumberId)
    }

    function checkReadSMSChannel(auth) {
      return currentUserIsServiceAccount(auth);
    }

    function checkCreateSMSChannel(auth, id) {
      return currentUserIsServiceAccount(auth) &&
        validateSMSChannel(getSMSChannelAfter(id)) &&
        indexedIdMatchesAfter(
          'SMSChannel',
          ['userPhoneNumberId', 'internalPhoneNumberId'],
          id
        )
    }

    match /SMSChannels/{id} {
      // NOTE: only allow ServiceAccounts to read and write
      allow read: if checkReadSMSChannel(request.auth)
      allow create: if checkCreateSMSChannel(request.auth, id)
      allow update: if currentUserIsServiceAccount(request.auth) &&
        validateSMSChannel(resource) &&
        indexedIdMatchesAfter(
          'SMSChannel',
          ['userPhoneNumberId', 'internalPhoneNumberId'],
          id
        );

      allow delete: if currentUserIsServiceAccount(request.auth);
    }

    match /Indexes/SMSChannels/userPhoneNumberId_internalPhoneNumberId/{userPhoneNumberId_internalPhoneNumberId} {
      allow read: if currentUserIsServiceAccount(request.auth);
      allow create: if currentUserIsServiceAccount(request.auth) &&
        indexedValueMatchesAfter(
          'SMSChannel',
          'userPhoneNumberId_internalPhoneNumberId',
          userPhoneNumberId_internalPhoneNumberId
        );

      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // SMSMessage implementation
    // -----------------------------

    match /SMSMessages/{id} {
      // TODO: Add validation
      // NOTE: only allow ServiceAccounts to read and write
      allow read: if currentUserIsServiceAccount(request.auth);
      allow write: if currentUserIsServiceAccount(request.auth);
    }


    // Upload implementation
    // -----------------------------

    function getUploadAfter(id) {
      return getAfter(/$(databasePath())/Uploads/$(id))
    }

    function getUploadBefore(id) {
      return get(/$(databasePath())/Uploads/$(id))
    }

    function uploadExistsAfter(id) {
      return existsAfter(/$(databasePath())/Uploads/$(id))
    }

    function uploadExistsBefore(id) {
      return exists(/$(databasePath())/Uploads/$(id))
    }

    function validateUploadData(data) {
      return userExistsAfter(data.userId) &&
        (errorExistsAfter(data.errorId) || data.errorId == null) &&
        (isMap(data.meta) || !has('meta', data)) &&
        isString(data.source) &&
        includes(data.state, [
          'CANCELED',
          'COMPLETED',
          'ERROR',
          'PAUSED',
          'POST_PROCESSING',
          'RUNNING',
          'SUCCESS'
        ])
    }

    function validateUpload(resource) {
      return validateEntity(resource) &&
        validateUploadData(resource.data)
    }

    function checkReadUpload(auth, resource) {
      return currentUserCanReadPrivateEntity(auth, resource, resource.userId)
    }

    function checkCreateUpload(auth, id) {
      let upload = getUploadAfter(id);
      return upload != null && validateUpload(upload) &&
        currentUserCanCreateEntity(auth, upload)
    }

    function checkUpdateUpload(auth, id) {
      let upload = getUploadAfter(id);
      return upload != null && currentUserIsServiceAccount(auth) &&
        validateUpload(upload)
    }

    function checkDeleteUpload(auth) {
      return currentUserIsServiceAccount(auth);
    }

    match /Uploads/{id} {
      allow read: if checkReadUpload(request.auth, resource);
      allow create: if checkCreateUpload(request.auth, id);
      allow update: if checkUpdateUpload(request.auth, id);
      allow delete: if checkDeleteUpload(request.auth);
    }


    // Url implementation
    // -----------------------------

    function getUrlAfter(id) {
      return getAfter(/$(databasePath())/Urls/$(id))
    }

    function getUrlBefore(id) {
      return get(/$(databasePath())/Urls/$(id))
    }

    function urlExistsAfter(id) {
      return existsAfter(/$(databasePath())/Urls/$(id))
    }

    function urlExistsBefore(id) {
      return exists(/$(databasePath())/Urls/$(id))
    }

    function validateUrlData(data) {
      // TODO BRN: replace this with more accurate checks
      return (isString(data.hash) || isNull(data.hash)) &&
        hostExistsAfter(data.hostId) &&
        isString(data.pathname) &&
        (isNumber(data.port) || isNull(data.port)) &&
        isString(data.protocol) &&
        (isString(data.search) || isNull(data.search))
    }

    function validateUrl(entity) {
      return validateEntity(entity) &&
        validateUrlData(entity.data);
    }

    function checkReadUrl(auth) {
      return currentUserIsServiceAccount(auth);
    }

    function checkCreateUrl(auth, id) {
      let urlAfter = getUrlAfter(id);
      return currentUserIsServiceAccount(auth) &&
        validateUrl(urlAfter);
    }

    function checkUpdateUrl(auth, id) {
      let urlAfter = getUrlAfter(id);
      return currentUserIsServiceAccount(auth) &&
        validateUrl(urlAfter);
    }

    function checkDeleteUrl(auth) {
      return currentUserIsServiceAccount(auth);
    }

    match /Urls/{id} {
      allow read: if checkReadUrl(request.auth);
      allow create: if checkCreateUrl(request.auth, id);
      allow update: if checkUpdateUrl(request.auth, id);
      allow delete: if checkDeleteUrl(request.auth);
    }


    // User implementation
    // -----------------------------

    function getUserAfter(id) {
      return getAfter(/$(databasePath())/Users/$(id))
    }

    function getUserBefore(id) {
      return get(/$(databasePath())/Users/$(id))
    }

    function userExistsAfter(id) {
      return existsAfter(/$(databasePath())/Users/$(id))
    }

    function userExistsBefore(id) {
      return exists(/$(databasePath())/Users/$(id))
    }

    function validateUser(resource) {
      return validateEntity(resource) &&
        (isString(resource.data.name) || !has('name', resource.data)) &&
        isString(resource.data.state) &&
          (resource.data.state == 'disabled' || resource.data.state == 'pending' || resource.data.state == 'valid')
    }

    match /Users/{id} {
      allow read: if currentUserCanReadProtectedEntity(request.auth, resource);

      allow create: if validateUser(getUserAfter(id)) && (
        currentUserIsServiceAccount(request.auth) ||
        // Users can only create Users that are pending
        (getUserAfter(id).data.state == 'pending')
      );
      // TODO BRN: validate that createdAt times don't change
      // TODO BRN: For right now only ServiceAccounts can update users.
      // It would be best to move "name" to a UserProfile object that can safely
      // be managed by the user without tampering with system things
      allow update: if currentUserIsServiceAccount(request.auth)

      // Only allow ServiceAccounts to delete
      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // UserPhoneNumber implementation
    // -----------------------------

    function getUserPhoneNumberAfter(phoneNumberId) {
      return getAfter(/$(databasePath())/UserPhoneNumbers/$(phoneNumberId))
    }

    function getUserPhoneNumberBefore(phoneNumberId) {
      return get(/$(databasePath())/UserPhoneNumbers/$(phoneNumberId))
    }

    function userPhoneNumberExistsAfter(phoneNumberId) {
      return existsAfter(/$(databasePath())/UserPhoneNumbers/$(phoneNumberId))
    }

    function userPhoneNumberExistsBefore(phoneNumberId) {
      return exists(/$(databasePath())/UserPhoneNumbers/$(phoneNumberId))
    }

    function validateUserPhoneNumber(resource) {
      return resource.id == resource.data.phoneNumberId &&
        userExistsAfter(resource.data.userId) &&
        phoneNumberExistsAfter(resource.data.phoneNumberId) &&
        getPhoneNumberAfter(resource.data.phoneNumberId).data.type == 'user'
    }

    match /UserPhoneNumbers/{phoneNumberId} {
      allow read: if currentUserCanReadProtectedEntity(request.auth, resource);

      allow create: if validateUserPhoneNumber(getUserPhoneNumberAfter(phoneNumberId)) && currentUserIsServiceAccount(request.auth);
      allow update: if false;
      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // UserPreference implementation
    // -----------------------------

    function getUserPreferencesAfter(id) {
      return getAfter(/$(databasePath())/UserPreferences/$(id))
    }

    function getUserPreferencesBefore(id) {
      return get(/$(databasePath())/UserPreferences/$(id))
    }

    function userPreferencesExistsAfter(id) {
      return existsAfter(/$(databasePath())/UserPreferences/$(id))
    }

    function userPreferencesExistsBefore(id) {
      return exists(/$(databasePath())/UserPreferences/$(id))
    }

    function validateUserPreferencesData(data) {
      return userExistsAfter(data.userId);
    }

    function validateUserPreferences(userPreferences) {
      return validateEntity(userPreferences) &&
        userPreferences.id == userPreferences.data.userId &&
        validateUserPreferencesData(userPreferences.data);
    }

    function checkReadUserPreferences(auth, resource) {
      // Only the owning user can read UserPreferences
      return currentUserCanReadPrivateEntity(auth, resource, false);
    }

    function checkCreateUserPreferences(auth, id) {
      // Users can create their own UserPreferences
      let userPreferencesAfter = getUserPreferencesAfter(id);
      return validateUserPreferences(userPreferencesAfter) &&
        id == userPreferencesAfter.data.userId &&
        currentUserCanCreateEntity(auth, userPreferencesAfter);
    }

    function checkUpdateUserPreferences(auth, id) {
      // Users can only update their own UserPreferences
      // TODO BRN: validate that createdAt times don't change
      let userPreferencesAfter = getUserPreferencesAfter(id);
      let userPreferencesBefore = getUserPreferencesBefore(id);
      return validateUserPreferences(userPreferencesAfter) &&
        id == userPreferencesAfter.data.userId &&
        currentUserCanUpdateEntity(auth, userPreferencesBefore, false);
    }

    function checkDeleteUserPreferences(auth) {
      // Only allow ServiceAccounts to delete UserPreferences
      return currentUserIsServiceAccount(auth);
    }

    function currentUserCanCreateUserPreferences(auth, userPreferencesId) {
      return currentUserCanCreateEntity(auth, getUserPreferencesBefore(userPreferencesId))
    }

    function currentUserCanUpdateUserPreferences(auth, userPreferencesId, allowRestores) {
      return currentUserCanUpdateEntity(auth, getUserPreferencesBefore(userPreferencesId), allowRestores)
    }

    match /UserPreferences/{id} {
      allow read: if checkReadUserPreferences(request.auth, resource);
      allow create: if checkCreateUserPreferences(request.auth, id);
      allow update: if checkUpdateUserPreferences(request.auth, id);
      allow delete: if checkDeleteUserPreferences(request.auth);
    }


    // UserProfile implementation
    // -----------------------------

    function getUserProfileAfter(id) {
      return getAfter(/$(databasePath())/UserProfiles/$(id))
    }

    function getUserProfileBefore(id) {
      return get(/$(databasePath())/UserProfiles/$(id))
    }

    function userProfileExistsAfter(id) {
      return existsAfter(/$(databasePath())/UserProfiles/$(id))
    }

    function userProfileExistsBefore(id) {
      return exists(/$(databasePath())/UserProfiles/$(id))
    }

    function validateUserProfileData(data) {
      return isString(data.name) &&
        userExistsAfter(data.userId) &&
        (!has('bio', data) || isString(data.bio)) &&
        (!has('location', data) || isString(data.location)) &&
        (!has('website', data) || isString(data.website)) &&
        (!has('userProfileImageId', data) || userProfileImageExistsAfter(data.userProfileImageId));
    }

    function validateUserProfile(userProfile) {
      return validateEntity(userProfile) &&
        userProfile.id == userProfile.data.userId &&
        validateUserProfileData(userProfile.data);
    }

    function checkReadUserProfile(auth, resource) {
      // Anyone can read UserProfiles
      return currentUserCanReadPublicEntity(auth, resource, false);
    }

    function checkCreateUserProfile(auth, id) {
      // Users can create their own UserProfiles
      let userProfileAfter = getUserProfileAfter(id);
      return validateUserProfile(userProfileAfter) &&
        id == userProfileAfter.data.userId &&
        currentUserCanCreateEntity(auth, userProfileAfter);
    }

    function checkUpdateUserProfile(auth, id) {
      // Users can only update their own UserProfiles
      // TODO BRN: validate that createdAt times don't change
      let userProfileAfter = getUserProfileAfter(id);
      let userProfileBefore = getUserProfileBefore(id);
      return validateUserProfile(userProfileAfter) &&
        id == userProfileAfter.data.userId &&
        currentUserCanUpdateEntity(auth, userProfileBefore, false);
    }

    function checkDeleteUserProfile(auth) {
      // Only allow ServiceAccounts to delete UserProfiles
      return currentUserIsServiceAccount(auth);
    }

    match /UserProfiles/{id} {
      allow read: if checkReadUserProfile(request.auth, resource);
      allow create: if checkCreateUserProfile(request.auth, id);
      allow update: if checkUpdateUserProfile(request.auth, id);
      allow delete: if checkDeleteUserProfile(request.auth);
    }


    // UserProfileImage implementation
    // -----------------------------

    function getUserProfileImageAfter(id) {
      return getAfter(/$(databasePath())/UserProfileImages/$(id))
    }

    function getUserProfileImageBefore(id) {
      return get(/$(databasePath())/UserProfileImages/$(id))
    }

    function userProfileImageExistsAfter(id) {
      return existsAfter(/$(databasePath())/UserProfileImages/$(id))
    }

    function userProfileImageExistsBefore(id) {
      return exists(/$(databasePath())/UserProfileImages/$(id))
    }

    function validateUserProfileImage(resource) {
      return validateTimestamped(resource) &&
        userExistsAfter(resource.data.userId) &&
        imageExistsAfter(resource.data.imageId);
    }

    match /UserProfileImages/{id} {
      allow read: if currentUserCanReadPublicEntity(request.auth, resource, false);

      allow create: if currentUserIsServiceAccount(request.auth) &&
        validateUserProfileImage(getUserProfileImageAfter(id)) &&
        indexedIdMatchesAfter(
          'UserProfileImage',
          ['userId', 'imageId'],
          id
        );

      allow update: if false;
      allow delete: if currentUserIsServiceAccount(request.auth);
    }

    match /Indexes/UserProfileImages/userId_imageId/{userId_imageId} {
      allow read: if currentUserIsServiceAccount(request.auth);
      allow create: if currentUserIsServiceAccount(request.auth) &&
        indexedValueMatchesAfter(
          'UserProfileImage',
          'userId_imageId',
          userId_imageId
        );

      allow delete: if currentUserIsServiceAccount(request.auth);
    }

    // UserRoles implementation
    // -----------------------------

    function getUserRoleAfter(id) {
      return getAfter(/$(databasePath())/UserRoles/$(id))
    }

    function getUserRoleBefore(id) {
      return userRoleExistsBefore(id) ?
        get(/$(databasePath())/UserRoles/$(id)) : null
    }

    function userRoleExistsAfter(id) {
      return existsAfter(/$(databasePath())/UserRoles/$(id))
    }

    function userRoleExistsBefore(id) {
      return exists(/$(databasePath())/UserRoles/$(id))
    }

    function validateUserRole(resource) {
      return validateEntity(resource) &&
        resource.id == resource.data.userId &&
        userExistsAfter(resource.data.userId) &&
        resource.data.role == 'admin' // the only type of role at the moment
    }

    match /UserRoles/{id} {
      // NOTE BRN: We use the id here instead of the resouce so that the User
      // can query for the UserRole even if a role doesn't exist.
      allow read: if currentUserCanReadPrivateEntity(request.auth, resource, id)

      allow create: if currentUserIsServiceAccount(request.auth) &&
        validateUserRole(getUserRoleAfter(id));

      allow update: if currentUserIsServiceAccount(request.auth) &&
        validateUserRole(getUserRoleAfter(id));

      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // Variable implementation
    // -----------------------------

    function getVariableAfter(id) {
      return getAfter(/$(databasePath())/Variables/$(id))
    }

    function getVariableBefore(id) {
      return get(/$(databasePath())/Variables/$(id))
    }

    function variableExistsAfter(id) {
      return existsAfter(/$(databasePath())/Variables/$(id))
    }

    function variableExistsBefore(id) {
      return exists(/$(databasePath())/Variables/$(id))
    }

    function validateVariable(resource) {
      return validateTimestamped(resource) &&
        isString(resource.id) &&
        has('value', resource.data)
    }

    match /Variables/{id} {
      allow read: if currentUserCanReadPublicEntity(request.auth, resource, false);

      allow create: if validateVariable(getVariableAfter(id)) && currentUserIsServiceAccount(request.auth);
      allow update: if validateVariable(getVariableAfter(id)) && currentUserIsServiceAccount(request.auth);
      allow delete: if currentUserIsServiceAccount(request.auth);
    }


    // UserImage implementation
    // -----------------------------

    function getUserImageAfter(id) {
      return getAfter(/$(databasePath())/UserImages/$(id))
    }

    function getUserImageBefore(id) {
      return get(/$(databasePath())/UserImages/$(id))
    }

    function userImageExistsAfter(id) {
      return existsAfter(/$(databasePath())/UserImages/$(id))
    }

    function userImageExistsBefore(id) {
      return exists(/$(databasePath())/UserImages/$(id))
    }

    function validateUserImage(resource) {
      return validateEntity(resource) &&
        imageExistsAfter(resource.data.imageId) &&
        userExistsAfter(resource.data.userId)
    }

    match /UserImages/{id} {
      allow read: if currentUserCanReadPublicEntity(request.auth, resource, false);

      allow create: if currentUserIsServiceAccount(request.auth) &&
        validateUserImage(getUserImageAfter(id)) &&
        indexedIdMatchesAfter(
          'UserImage',
          ['userId', 'imageId'],
          id
        );

      allow update: if currentUserIsServiceAccount(request.auth) &&
        validateUserImage(getUserImageAfter(id)) &&
        indexedIdMatchesAfter(
          'UserImage',
          ['userId', 'imageId'],
          id
        );

      allow delete: if currentUserIsServiceAccount(request.auth);
    }

    match /Indexes/UserImages/userId_imageId/{userId_imageId} {
      allow read: if currentUserIsServiceAccount(request.auth);
      allow create: if currentUserIsServiceAccount(request.auth) &&
        indexedValueMatchesAfter(
          'UserImage',
          'userId_imageId',
          userId_imageId
        );

      allow delete: if currentUserIsServiceAccount(request.auth);
    }
  }
}

function somePath() {
  return (/foo/bar)
}
function somePath() {
 return /foo/bar
}

function function_with_underscore () {
  return (/path-with-dashes)
}

match /path-with-hyphens {
  allow read: if exists(function_with_underscore()) && exists(/path-with/hyphen)
}

match /lte {
  allow read: if (request.query.something <= 100)
}

match /gte {
  allow read: if request.query.something >= 100
}

match /collection:with:colon {
  allow read: if true;
}

function userExists() {
  return exists(/users/$(request.auth.uid))
}

function test (a,b) {
  return true
}

match /test/test {
  allow read: if test(true, 'asdf');
}

match /test/test {
  allow read: if data().keys().hasAll(['a', 'b', 'c']);
}

function b () {
  return "adsf"
}

match /test/{a} {
  allow read: if exists(/test/$(a)/$(b())/$(b(a)))
}

match /test/{a} {
  allow read
}

match /users/{id} {
  allow write: if name.matches('test');
}

// https://firebase.google.com/docs/firestore/security/rules-conditions
match /firestore_rules_conditions {
  // True if the user is signed in or the requested data is 'public'
  function signedInOrPublic() {
    return request.auth.uid != null || resource.data.visibility == 'public';
  }

  match /cities/{city} {
    allow read, write: if signedInOrPublic();
  }

  match /users/{user} {
    allow read, write: if signedInOrPublic();
  }

  match /cities/{city} {
    allow create: if exists(/databases/$(database)/documents/users/$(request.auth.uid))
      allow delete: if get(/databases/$(database)/documents/users/$(request.auth.uid)).data.admin == true
  }

  match /cities/{city} {
    allow update: if request.resource.data.population > 0
      && request.resource.data.name == resource.data.name;
  }
}

match /sage_team_cheezit {
  // https://github.com/UMM-CSci-3601-F17/sage-team-cheezit/blob/1cdce21fd7d80874654d9f913d022753e7a07f9e/firestore.rules
  // Licence: MIT (https://github.com/UMM-CSci-3601-F17/sage-team-cheezit/blob/1cdce21fd7d80874654d9f913d022753e7a07f9e/LICENSE)
  match /decks/{deck} {
    allow read: if resource.data.isPublic == true || (request.auth != null && //checks if the user is logged in
        (request.auth.uid in resource.data.users || //checks if the user is in the users of the deck
         request.auth.uid in get(/databases/$(database)/documents/classes/$(resource.data.classId)).data.users)); //checks if the user is in the class that the deck is in

    allow create: if request.auth != null && //checks if they are logged in
      request.resource.data.name is string && //checks to make sure the deck name is a string
      ((request.auth.uid in request.resource.data.users && //check that they are a user in the decks users if it is in my decks
        request.resource.data.users[request.auth.uid].owner == true && //checks that the user is a deck owner in the users if it is in my decks
        request.resource.data.users != null && //checks that users are being added to the deck
        request.resource.data.name != null && //checks that a name is being added to the deck
        request.resource.data.size() == 2) || //check that there are only 2 field values on the deck when its being added, name and users
       (request.resource.data.classId is string && //checks if the class Id is a string
        get(/databases/$(database)/documents/classes/$(request.resource.data.classId)).data.users[request.auth.uid].teacher == true) && //checks if the user in the class is a teacher
       request.resource.data.classId != null && //checks that a classId is being added to the deck
       request.resource.data.name != null && //checks that a name is being added to the deck
       request.resource.data.size() == 2); //check that there are only 2 field values on the deck when its being added, name and classId

    allow update: if request.auth != null && //checks if the user is logged in
      request.resource.data.name is string && //checks to make sure the deck name is a string for renaming
      ((request.auth.uid in resource.data.users && //check that they are a user in the decks users if it is in my decks
        resource.data.users[request.auth.uid].owner == true && //checks that the user is a deck owner in the users if it is in my decks
        (request.resource.data.users[request.auth.uid].owner == true || //checks to make sure if the user is moving a deck to my decks that its only being send to their my decks
         get(/databases/$(database)/documents/classes/$(request.resource.data.classId)).data.users[request.auth.uid].teacher == true)) || //checks to make sure that if the user is moving a deck to a class they have to be a teacher in it
       (resource.data.classId is string && //checks if the class Id is a string
        get(/databases/$(database)/documents/classes/$(resource.data.classId)).data.users[request.auth.uid].teacher == true && //checks if the user in the class is a teacher
        (request.resource.data.users[request.auth.uid].owner == true || //checks to make sure if the user is moving a deck to my decks that its only being send to their my decks
         get(/databases/$(database)/documents/classes/$(request.resource.data.classId)).data.users[request.auth.uid].teacher == true))); //checks to make sure that if the user is moving a deck to a class they have to be a teacher in it

    allow delete: if request.auth != null && //checks if the user is logged in
      ((request.auth.uid in resource.data.users && //check that they are a user in the decks users if it is in my decks
        resource.data.users[request.auth.uid].owner == true) || //checks that the user is a deck owner in the users if it is in my decks
       (resource.data.classId is string && //checks if the class Id is a string
        get(/databases/$(database)/documents/classes/$(resource.data.classId)).data.users[request.auth.uid].teacher == true)) //checks if the user in the class is a teacher


      match /cards/{card} {
        function getDeck() {
          return get(/databases/$(database)/documents/decks/$(deck)).data;
        }

        allow read: if true; //allows all people to read, this is already blocked by decks

        allow create, update: if request.auth != null && //checks if the user is logged in
          request.resource.data.synonym is list && //checks that the synonym is a list
          request.resource.data.synonym.size() > 0 && //checks that the size of the list of synonyms is atleast 1
          request.resource.data.antonym is list && //checks that the antonym is a list
          request.resource.data.antonym.size() > 0 && //checks that the size of the list of antonyms is atleast 1
          request.resource.data.general_sense is string && //checks that the general sense is a string
          request.resource.data.general_sense.size() > 0 && //checks that the general sense is atleast 1 letter long
          request.resource.data.example_usage is string && //checks that the example usage is a string
          request.resource.data.example_usage.size() > 0 && //checks that the example usage is atleast 1 letter long
          request.resource.data.word is string && //checks that the word is a string
          request.resource.data.word.size() > 0 && //checks that the word is atleast 1 letter long
          ((getDeck().users[request.auth.uid].owner == true) || //checks if the user owns the deck they are editing cards in
           (request.auth.uid in get(/databases/$(database)/documents/classes/$(getDeck().classId)).data.users && //checks if the user is in the class that the cards deck is in
            getDeck().studentEdit == true) || //checks if student editing is enabled in said deck
           (get(/databases/$(database)/documents/classes/$(getDeck().classId)).data.users[request.auth.uid].teacher == true)); //checks if the user is a teacher in the class that the cards deck is in

        allow delete: if request.auth != null && //checks if the user is logged in
          ((getDeck().users[request.auth.uid].owner == true) || //checks if the user owns the deck they are editing cards in
           (request.auth.uid in get(/databases/$(database)/documents/classes/$(getDeck().classId)).data.users && //checks if the user is in the class that the cards deck is in
            getDeck().studentEdit == true) || //checks if student editing is enabled in said deck
           (get(/databases/$(database)/documents/classes/$(getDeck().classId)).data.users[request.auth.uid].teacher == true)); //checks if the user is a teacher in the class that the cards deck is in
      }
  }
  match /classes/{class} {
    allow read: if request.auth != null && //checks if the user is logged in
      request.auth.uid in resource.data.users; //checks if they are in the class

    allow create: if request.auth != null && //checks if the user is logged in
      request.resource.data.name is string && //checks if the class name is a string
      request.resource.data.users.size() == 1 && //checks if only one user is being added to the new class
      request.auth.uid in request.resource.data.users && //checks if the user creating the class is in it
      request.resource.data.users[request.auth.uid].teacher == true; //checks if said person is set as a teacher

    allow update: if request.auth != null && //checks if the user is logged in
      (resource.data.users[request.auth.uid].teacher == true || //checks if the user is the teacher of the class
       (request.resource.data.size() == resource.data.size() && //This is for students leaving classes, checks to make sure no fields were added or deleted
        request.resource.data.joincode == resource.data.joincode && //checks to make sure the joincode hasn't changed
        request.resource.data.name == resource.data.name && //checks to make sure the class name hasn't changed
        request.resource.data.users.size() == resource.data.users.size() - 1 && //checks to make sure the user list has only reduced by one user
        !(request.auth.uid in request.resource.data.users))|| //checks to make sure the user being deleted is the user doing it
       (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.joincode == resource.data.joincode && //This is for students joining classes, checks to make sure the user has a joincode
        !(request.auth.uid in resource.data.users) && //checks that the user is not already in the class
        request.resource.data.size() == resource.data.size() && //checks to make sure no fields were added or deleted
        request.resource.data.joincode == resource.data.joincode && //checks to make sure the joincode hasn't changed
        request.resource.data.name == resource.data.name && //checks to make sure the class name hasn't changed
        request.resource.data.users[request.auth.uid].teacher == false && //checks to make sure the user is not a teacher
        request.resource.data.users.size() == resource.data.users.size() + 1 //checks to make sure the user list has only increased by one user
       ));

    //Because we have an undo button for removing students we cannot lock down teachers adding students
    //The only place uid's can be gathered at the moment is in classes as far as we can tell which
    //is already blocked by the join code so we are going to continue allowing teachers to add students.

    allow delete: if request.auth != null && resource.data.users[request.auth.uid].teacher == true; //checks if the user is a teacher
  }
  match /users/{user} {
    allow read, write: if request.auth.uid == user; //checks if the user id is the same as the document id
  }
}

match /doocrate {
  // https://github.com/Metaburn/doocrate/blob/936d55901a990bd1094f6e866e2ad02166f67d53/rules/firestore.rules
  // Licence: MIT (https://github.com/Metaburn/doocrate/blob/936d55901a990bd1094f6e866e2ad02166f67d53/LICENSE)
  function isSignedIn() {
    return request.auth != null;
  }

  //Read more about this here - https://dev.to/chinchang/restrict-specific-fields-updation-in-firebase-firestore-ohp
  function notUpdating(field) {
    return !(field in request.resource.data)
      || resource.data[field] == request.resource.data[field]
  }

  // This is root level admin
  function isSuperAdmin() {
    return exists(/databases/$(database)/documents/super_admins/$(request.auth.uid));
  }

  function isSpecificProjectAdmin(anyProject) {
    return exists(/databases/$(database)/documents/admins/$(request.auth.uid)/projects/$(anyProject))
  }

  function isGuide() {
    return exists(/databases/$(database)/documents/guides/$(request.auth.uid));
  }

  function isCreator() {
    return resource.data.creator != null &&
      (request.auth.uid == resource.data.creator.data.id || request.auth.uid == resource.data.creator.id);
  }

  function isUserAssignee() {
    return resource.data.assignee != null &&
      (request.auth.uid == resource.data.assignee.data.id || request.auth.uid == resource.data.assignee.id);
  }

  function isUserAssigneeOrCreator() {
    return isCreator() || isUserAssignee();
  }

  function isTaskUnassigned() {
    return (request.resource.data.keys().hasAll(['assignee'])
        && !resource.data.keys().hasAll(['assignee']));
  }

  // Check if project is public
  // or if user has an email under the invites
  function isUserInvited(anyProject) {
    //return get(/databases/$(database)/documents/projects/$(anyProject)).data.isPublic ||
    return request.auth.token.email in get(/databases/$(database)/documents/projects/$(anyProject)/invitation_lists/main).data.invites;
  }

  // Since firebase doesn't have the ability to specify what CAN be updated
  // We need to say what CANNOT be updated - that is all of the tasks fields BUT listeners
  function isNotUpdatingAnythingButListeners() {
    return notUpdating('id') && notUpdating('title') && notUpdating('assignee')
      && notUpdating('type') && notUpdating('projectName') && notUpdating('label')
      && notUpdating('created') && notUpdating('dueDate') && notUpdating('creator')
      && notUpdating('isDone') && notUpdating('doneDate') && notUpdating('description')
      && notUpdating('requirements') && notUpdating('isCritical') && notUpdating('extraFields');
  }

  // Allow create for anyone who is auth
  // Allow to update it the user is the project creator
  match /projects/{anyProject} {
    allow create: if isSignedIn();
    allow read: if true; //Allow all to read the existing project
    allow update: if isSignedIn() && isCreator() || isSuperAdmin();
    allow delete: if isSignedIn() && isCreator() || isSuperAdmin();

    match /tasks/{anyTask} {
      allow read: if isSignedIn();
      // Allow create: if authenticated
      // Uncommment the canCreateTask will not allow users who already have tasks to create new tasks
      allow create: if isSignedIn() && isUserInvited(anyProject) || isSpecificProjectAdmin(anyProject) || isSuperAdmin();
      // Uncomment the following to allow unassigned task to be assigned by all
      allow update: if isSignedIn() && isNotUpdatingAnythingButListeners()
        ||
        (isUserInvited(anyProject) && (isGuide() || isUserAssigneeOrCreator()
                                       || isTaskUnassigned() || isNotUpdatingAnythingButListeners())
        )
        || isSpecificProjectAdmin(anyProject) || isSuperAdmin();
      allow delete: if isSignedIn() && isSpecificProjectAdmin(anyProject) || (isUserInvited(anyProject) && isCreator()) || isSuperAdmin();
    }

    match /comments/{anyComment} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && isUserInvited(anyProject) || isSpecificProjectAdmin(anyProject) || isSuperAdmin();
      allow update: if isSignedIn() && isCreator();
      allow delete: if isSignedIn() && isCreator();
    }

    match /invitation_lists/{anyInvitationList} {
      allow create: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
      allow read: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
      allow update: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
      allow delete: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
    }

    match /invitations/{anyInvitation} {
      allow create: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
      allow read: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
      allow update: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
      allow delete: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
    }

    match /colors/{anyColor} {
      allow create: if isSignedIn();
      allow read: if isSignedIn();
      allow update: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
      allow delete: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
    }

    match /labels/{anyLabel} {
      allow create: if isSignedIn();
      allow read: if isSignedIn();
      allow update: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
      allow delete: if isSignedIn() && (isSpecificProjectAdmin(anyProject) || isSuperAdmin());
    }
  }

  match /users/{userId} {
    allow read: if isSignedIn(); // Auth users can read
    allow write: if userId == request.auth.uid || isSuperAdmin();
  }

  match /admins/{anyAdmin} {
    allow read: if isSignedIn();
    match /projects/{anyProject} {
      allow read: if isSignedIn();
    }
  }

  match /guides/{anyGuide} {
    allow read: if isSignedIn();
  }
}

match /nobox {
  // https://github.com/Lipnevich/noxbox/blob/bbe06542bc486f1425a19ec0b97cbd85b1d0738c/functions/firestore.rules
  // Licence: Apache Licence 2.0 (https://github.com/Lipnevich/noxbox/blob/bbe06542bc486f1425a19ec0b97cbd85b1d0738c/README.md)

  match /ratings/{profileId} {
    allow get: if request.auth.uid != null;
  }

  match /profiles/{profileId} {
    allow get: if request.auth.uid == profileId;
    allow create, update: if allowToProfileUpdate()
      && request.auth.uid == profileId;
  }

  function allowToProfileUpdate(){
    return resource.data.wallet.address == request.resource.data.wallet.address
      && request.resource.data.id == request.auth.uid
      // allow to add or remove link to new noxbox
      // in case current noxbox is finished
      && (resource.data.noxboxId == ''
          || resource.data.noxboxId == request.resource.data.noxboxId
          || !exists(/databases/$(database)/documents/noxboxes/$(resource.data.noxboxId))
          || get(/databases/$(database)/documents/noxboxes/$(resource.data.noxboxId)).data.finished == true);
  }


  match /noxboxes/{noxboxId} {
    allow create: if allowToCreateNoxbox() && request.resource.data.id == noxboxId;
    allow update: if allowToNoxboxUpdate();

    allow get: if allowToGetNoxbox();
    allow list: if request.query.limit <= 100 &&
      allowToListNoxboxes();
  }



  function allowToGetNoxbox() {
    return request.auth.uid != null
      && (resource.data.timeRequested == 0
          || resource.data.owner.id == request.auth.uid
          || resource.data.party.id == request.auth.uid);
  }

  function allowToListNoxboxes() {
    return request.auth.uid != null
      && resource.data.finished
      && (resource.data.payerId == request.auth.uid
          || resource.data.performerId == request.auth.uid);
  }

  function allowToCreateNoxbox(){
    return request.auth.uid != null
      && request.resource.data.owner.id == request.auth.uid
      && request.resource.data.timeCreated > 0
      && request.resource.data.timeRemoved == 0
      && request.resource.data.timeRequested == 0
      && request.resource.data.timeCompleted == 0
      && request.resource.data.timeAccepted == 0
      && request.resource.data.timeCanceledByOwner == 0
      && request.resource.data.timeCanceledByParty == 0
      && request.resource.data.timeOwnerVerified == 0
      && request.resource.data.timePartyVerified == 0
      && request.resource.data.timeOwnerDisliked == 0
      && request.resource.data.timeOwnerLiked == 0
      && request.resource.data.timePartyDisliked == 0
      && request.resource.data.timePartyLiked == 0
      && request.resource.data.timeTimeout == 0
      && request.resource.data.finished == false
      && request.resource.data.role != null
      && request.resource.data.type != null
      && request.resource.data.price != null
      && get(/databases/$(database)/documents/profiles/$(request.auth.uid)).data.noxboxId == request.resource.data.id;
  }


  function allowToNoxboxUpdate(){
    return request.auth.uid != null
      // Constants
      && request.resource.data.id == resource.data.id
      && request.resource.data.role == resource.data.role
      && request.resource.data.type == resource.data.type
      && request.resource.data.price == resource.data.price
      && request.resource.data.owner.id == resource.data.owner.id
      // Only owner or party can update
      && ((request.resource.data.owner.id == request.auth.uid
            && (resource.data.timeRequested == 0
              || request.resource.data.party.id == resource.data.party.id))
          || (request.resource.data.party.id == request.auth.uid
            &&  (resource.data.timeRequested == 0
              || request.resource.data.party.id == resource.data.party.id)))
      //Protect supply roles
      && ((request.resource.data.owner.id == request.resource.data.performerId
            && (request.resource.data.payerId == ''
              || request.resource.data.party.id == request.resource.data.payerId)
            && request.resource.data.role == 'supply')
          //Protect demand roles
          || (request.resource.data.owner.id == request.resource.data.payerId
            && (request.resource.data.performerId == ''
              || request.resource.data.party.id == request.resource.data.performerId)
            && request.resource.data.role == 'demand'))
      // Operations order
      && request.resource.data.timeRatingUpdated >= resource.data.timeRatingUpdated
      && request.resource.data.timeOwnerDisliked >= resource.data.timeOwnerDisliked
      && request.resource.data.timeOwnerLiked >= resource.data.timeOwnerLiked
      && request.resource.data.timePartyDisliked >= resource.data.timePartyDisliked
      && request.resource.data.timePartyLiked >= resource.data.timePartyLiked
      && (request.resource.data.timeRequested == resource.data.timeRequested
          || (resource.data.timeRequested == 0
            && request.resource.data.party.name != ''
            && request.resource.data.party.photo != ''
            && get(/databases/$(database)/documents/profiles/$(request.auth.uid)).data.wallet.address == request.resource.data.party.wallet.address))
      && (request.resource.data.timeAccepted == resource.data.timeAccepted
          || (resource.data.timeAccepted == 0
            && resource.data.timeRequested > 0
            && request.resource.data.owner.name != ''
            && request.resource.data.owner.photo != ''
            && get(/databases/$(database)/documents/profiles/$(request.auth.uid)).data.wallet.address == request.resource.data.owner.wallet.address))
      && (request.resource.data.timeTimeout == resource.data.timeTimeout
          || (resource.data.timeTimeout == 0 && resource.data.timeAccepted == 0))
      && (request.resource.data.timeCanceledByOwner == resource.data.timeCanceledByOwner
          || (resource.data.timeCanceledByOwner == 0
            && (resource.data.timeOwnerVerified == 0 || resource.data.timePartyVerified == 0)))
      && (request.resource.data.timeCanceledByParty == resource.data.timeCanceledByParty
          || (resource.data.timeCanceledByParty == 0
            && (resource.data.timeOwnerVerified == 0 || resource.data.timePartyVerified == 0)))
      && (request.resource.data.timeOwnerRejected == resource.data.timeOwnerRejected
          || (resource.data.timeOwnerRejected == 0
            && resource.data.timeOwnerVerified == 0))
      && (request.resource.data.timePartyRejected == resource.data.timePartyRejected
          || (resource.data.timePartyRejected == 0
            && resource.data.timePartyVerified == 0))
      && (request.resource.data.timeOwnerVerified == resource.data.timeOwnerVerified
          || (resource.data.timeOwnerVerified == 0
            && resource.data.timeAccepted > 0
            && resource.data.timeOwnerRejected == 0))
      && (request.resource.data.timePartyVerified == resource.data.timePartyVerified
          || (resource.data.timePartyVerified == 0
            && resource.data.timeAccepted > 0
            && resource.data.timePartyRejected == 0))
      && (request.resource.data.timeCompleted == resource.data.timeCompleted
          || (resource.data.timeCompleted == 0
            && resource.data.timeOwnerVerified > 0
            && resource.data.timePartyVerified > 0))
      //Photo replacement owner
      && (request.resource.data.owner.photo == resource.data.owner.photo
          || (request.auth.uid == resource.data.owner.id
            && resource.data.timePartyRejected == 0
            && resource.data.timePartyVerified == 0))
      //Photo replacement party
      && (resource.data.timeRequested == 0
          || (request.resource.data.party.photo == resource.data.party.photo
            || (request.auth.uid == resource.data.party.id
              && resource.data.timeOwnerRejected == 0
              && resource.data.timeOwnerVerified == 0)))
      // Allow finish service once
      && (request.resource.data.finished == resource.data.finished
          || resource.data.finished == false)
      // Party specific actions
      && ((request.resource.data.timeRequested == resource.data.timeRequested
            && request.resource.data.timeCanceledByParty == resource.data.timeCanceledByParty
            && request.resource.data.timePartyRejected == resource.data.timePartyRejected
            && request.resource.data.timePartyVerified == resource.data.timePartyVerified
            && request.resource.data.timePartyDisliked == resource.data.timePartyDisliked
            && (request.resource.data.timePartyLiked == resource.data.timePartyLiked
              // on complete
              || resource.data.timePartyLiked == 0))
          || request.resource.data.party.id == request.auth.uid)
      // Owner specific actions
      && ((request.resource.data.timeAccepted == resource.data.timeAccepted
            && request.resource.data.timeRemoved == resource.data.timeRemoved
            && request.resource.data.timeCanceledByOwner == resource.data.timeCanceledByOwner
            && request.resource.data.timeOwnerRejected == resource.data.timeOwnerRejected
            && request.resource.data.timeOwnerVerified == resource.data.timeOwnerVerified
            && request.resource.data.timeOwnerDisliked == resource.data.timeOwnerDisliked
            && (request.resource.data.timeOwnerLiked == resource.data.timeOwnerLiked
              // on complete
              || resource.data.timeOwnerLiked == 0))
          || request.resource.data.owner.id == request.auth.uid)
      //When noxbox active NONE of termination times must be set
      && ((request.resource.data.finished == false
            && request.resource.data.timeCanceledByOwner == 0
            && request.resource.data.timeCanceledByParty == 0
            && request.resource.data.timeOwnerRejected == 0
            && request.resource.data.timePartyRejected == 0
            && request.resource.data.timeCompleted == 0
            && request.resource.data.timeRemoved == 0
            && request.resource.data.timeTimeout == 0)
          //When noxbox was finished ONE of termination time must be set
          || (request.resource.data.finished == true
            && (request.resource.data.timeCanceledByOwner > 0
              || request.resource.data.timeCanceledByParty > 0
              || request.resource.data.timeOwnerRejected > 0
              || request.resource.data.timePartyRejected > 0
              || request.resource.data.timeCompleted > 0
              || request.resource.data.timeRemoved > 0
              || request.resource.data.timeTimeout > 0)));
  }
}

match hirelings {
  // https://github.com/BrotherKristoph/hirelings-api/blob/268385de42e72d6179d9677aa17a69f68a449361/firestore/firestore.rules
  // Licence: Apache Licence 2.0 (https://github.com/BrotherKristoph/hirelings-api/blob/268385de42e72d6179d9677aa17a69f68a449361/LICENSE)
  match /{document=**} {
    allow read, write: if false;
  }

  match /users {
    allow read, write: if false;

    match /{userId} {
      allow get: if request.auth.uid != null
        && request.auth.uid == userId
        && exists(/databases/$(database)/documents/users/$(userId));

      allow list: if false;

      allow update, delete: if request.auth.uid != null
        && request.auth.uid == userId
        && exists(/databases/$(database)/documents/users/$(userId));

      allow create: if request.auth.uid != null
        && request.auth.uid == userId
        && exists(/databases/$(database)/documents/users/$(userId)) == false;
    }
  }

  match /parties {
    allow read, write: if false;

    match /{party} {
      allow create: if request.auth.uid != null
        && exists(/databases/$(database)/documents/users/$(request.auth.uid))
        && exists(/databases/$(database)/documents/parties/$(party)) == false
        && request.resource.data.keys().hasAll([
            'gm',
            'balance',
            'currentDay'
        ])
        && request.resource.data.gm is string
        && request.resource.data.gm == request.auth.uid
        && request.resource.data.balance is int
        && request.resource.data.balance >= 0
        && request.resource.data.currentDay is int
        && request.resource.data.currentDay == 0;

      allow update: if request.auth.uid != null
        && exists(/databases/$(database)/documents/users/$(request.auth.uid))
        && exists(/databases/$(database)/documents/parties/$(party))
        && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm
        && request.resource.data.keys().hasAll([
            'gm',
            'balance',
            'currentDay'
        ])
        && request.resource.data.gm is string
        && request.resource.data.gm == request.auth.uid
        && request.resource.data.balance is int
        && request.resource.data.balance >= 0
        && request.resource.data.currentDay is int
        && request.resource.data.currentDay >= 0;

        allow delete: if request.auth.uid != null
        && exists(/databases/$(database)/documents/users/$(request.auth.uid))
        && exists(/databases/$(database)/documents/parties/$(party))
        && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm;

      allow get: if request.auth.uid != null
        && exists(/databases/$(database)/documents/users/$(request.auth.uid))
        && exists(/databases/$(database)/documents/parties/$(party))
        && request.auth.uid == resource.data.gm;

      allow list: if false;

      match /hirelings {
        allow read, write: if false;

        match /{hireling} {
          allow read: if request.auth.uid != null
            && exists(/databases/$(database)/documents/users/$(request.auth.uid))
            && exists(/databases/$(database)/documents/parties/$(party))
            && exists(/databases/$(database)/documents/parties/$(party)/hirelings/$(hireling))
            && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm;

          allow create: if request.auth.uid != null
            && exists(/databases/$(database)/documents/users/$(request.auth.uid))
            && exists(/databases/$(database)/documents/parties/$(party))
            && exists(/databases/$(database)/documents/parties/$(party)/hirelings/$(hireling)) == false
            && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm
            && request.resource.data.keys().hasAll([
                'level',
                'name',
                'role',
                'abilities',
                'currentMission'
            ])
            && request.resource.data.level is int
            && request.resource.data.level >= 1
            && request.resource.data.level <= 20
            && request.resource.data.name is string
            && request.resource.data.role is int
            && request.resource.data.role >= 0
            && request.resource.data.role <= 3
            && request.resource.data.abilities.size() >= 1
            && request.resource.data.abilities.size() <= 3
            && request.resource.data.currentMission is string
            && request.resource.data.currentMission == ''

            allow update: if request.auth.uid != null
            && exists(/databases/$(database)/documents/users/$(request.auth.uid))
            && exists(/databases/$(database)/documents/parties/$(party))
            && exists(/databases/$(database)/documents/parties/$(party)/hirelings/$(hireling))
            && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm
            && request.resource.data.keys().hasAll([
                'level',
                'name',
                'role',
                'abilities',
                'currentMission'
            ])
            && request.resource.data.level is int
            && request.resource.data.level >= 1
            && request.resource.data.level <= 20
            && request.resource.data.name is string
            && request.resource.data.role is int
            && request.resource.data.role >= 0
            && request.resource.data.role <= 3
            && request.resource.data.abilities.size() >= 1
            && request.resource.data.abilities.size() <= 3
            && request.resource.data.currentMission is string

            allow delete: if request.auth.uid != null
            && exists(/databases/$(database)/documents/users/$(request.auth.uid))
            && exists(/databases/$(database)/documents/parties/$(party))
            && exists(/databases/$(database)/documents/parties/$(party)/hirelings/$(hireling))
            && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm
        }
      }

      match /missions {
        allow read, write: if false;

        match /{mission} {
          allow read: if request.auth.uid != null
            && exists(/databases/$(database)/documents/users/$(request.auth.uid))
            && exists(/databases/$(database)/documents/parties/$(party))
            && exists(/databases/$(database)/documents/parties/$(party)/missions/$(mission))
            && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm;

          allow create: if request.auth.uid != null
            && exists(/databases/$(database)/documents/users/$(request.auth.uid))
            && exists(/databases/$(database)/documents/parties/$(party))
            && exists(/databases/$(database)/documents/parties/$(party)/missions/$(mission)) == false
            && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm
            && request.resource.data.keys().hasAll([
                'level',
                'name',
                'length',
                'challenges',
                'reward',
                'startDate',
                'status'
            ])
            && request.resource.data.length is int
            && request.resource.data.length >= 1
            && request.resource.data.level is int
            && request.resource.data.level >= 1
            && request.resource.data.level <= 20
            && request.resource.data.name is string
            && request.resource.data.reward is int
            && request.resource.data.reward >= 0
            && request.resource.data.startDate is int
            && request.resource.data.startDate >= 0
            && request.resource.data.status is int
            && request.resource.data.status == 0
            && request.resource.data.challenges.size() >= 0

            allow update: if request.auth.uid != null
            && exists(/databases/$(database)/documents/users/$(request.auth.uid))
            && exists(/databases/$(database)/documents/parties/$(party))
            && exists(/databases/$(database)/documents/parties/$(party)/missions/$(mission))
            && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm
            && request.resource.data.keys().hasAll([
                'level',
                'name',
                'length',
                'challenges',
                'reward',
                'startDate',
                'status'
            ])
            && request.resource.data.length is int
            && request.resource.data.length >= 1
            && request.resource.data.level is int
            && request.resource.data.level >= 1
            && request.resource.data.level <= 20
            && request.resource.data.name is string
            && request.resource.data.reward is int
            && request.resource.data.reward >= 0
            && request.resource.data.startDate is int
            && request.resource.data.startDate >= 0
            && request.resource.data.status is int
            && request.resource.data.status >= 0
            && request.resource.data.status <= 4
            && request.resource.data.challenges.size() >= 0

            allow delete: if request.auth.uid != null
            && exists(/databases/$(database)/documents/users/$(request.auth.uid))
            && exists(/databases/$(database)/documents/parties/$(party))
            && exists(/databases/$(database)/documents/parties/$(party)/missions/$(mission))
            && request.auth.uid == get(/databases/$(database)/documents/parties/$(party)).data.gm
        }
      }
    }
  }
}

match /biblo {
  // Licence: MIT (https://github.com/hill84/biblo/blob/2144fce970c4a866b7f62a20142f54c833d8ca27/LICENSE.md)
  // https://github.com/hill84/biblo/blob/2144fce970c4a866b7f62a20142f54c833d8ca27/firestore.rules
  /// RULES ///
  match /users/{uid} {
    allow read;
    allow create: if isValidUser();
    allow update: if (isEditor() && isAdmin()) || (isValidUser() && isOwner(uid));
    allow delete: if (isEditor() && isAdmin()) || isOwner(uid);

    match /challenges/{cid} {
      allow read;
      allow write: if (isEditor() && isAdmin()) || (isEditor() && isOwner(uid));
    }

    match /collectiones/{cid} {
      allow read;
      allow write: if (isEditor() && isAdmin()) || (isEditor() && isOwner(uid));
    }

    match /authors/{aid} {
      allow read;
      allow write: if (isEditor() && isAdmin()) || (isEditor() && isOwner(uid));
    }
  }

  match /notifications/{uid} {
    allow read;
    allow write: if isEditor();
  }

  match /{path=**}/notes/{uid} {
    allow read;
    allow write: if isEditor();
  }

  match /followers/{uid} {
    allow read;
    allow write: if isEditor();
  }

  match /followings/{uid} {
    allow read;
    allow write: if isEditor();
  }

  match /books/{bid} {
    allow read;
    allow create: if isEditor() && isValidBook();
    allow update: if isEditor() && isValidBook() && (incomingData().bid == existingData().bid);
    allow delete: if (isEditor() && isAdmin());
  }

  match /shelves/{uid} {
    allow read;
    allow write: if (isEditor() && isAdmin()) || (isEditor() && isOwner(uid));

    match /books/{bid} {
      allow read;
      allow create: if isEditor();
      allow update: if isEditor() && incomingData().bid == existingData().bid;
      allow delete: if isEditor();
    }
  }

  match /reviews/{bid} {
    allow read;
    allow write: if isEditor();
  }

  match /{path=**}/reviewers/{uid} {
    allow read;
    allow create, update: if isEditor();
    allow delete: if (isEditor() && isAdmin()) || (isEditor() && isOwner(uid));
  }

  // DEPRECATED
  match /feeds/latestReviews {
    allow read;
    allow write: if isEditor();

    match /reviews/{bid} {
      allow read;
      allow create, update: if isEditor();
      allow delete: if (isEditor() && isAdmin()) || (isEditor() && isOwner(uid));
    }
  }

  match /authors/{aid} {
    allow read;
    allow create, update: if isEditor();
    allow delete: if isEditor() && isAdmin();

    match /followers/{uid} {
      allow read;
      allow write: if isEditor();
    }
  }

  match /collections/{cid} {
    allow read;
    allow create, update: if isEditor();
    allow delete: if isEditor() && isAdmin();

    match /books/{bid} {
      allow read;
      allow create, update: if isEditor();
      allow delete: if isEditor() && isAdmin();
    }

    match /followers/{uid} {
      allow read;
      allow write: if isEditor();
    }
  }

  match /genres/{gid} {
    allow read;
    allow create, update: if isEditor();
    allow delete: if isEditor() && isAdmin();

    match /followers/{uid} {
      allow read;
      allow write: if isEditor();
    }
  }

  match /quotes/{qid} {
    allow read;
    allow write: if isEditor();
  }

  match /challenges/{cid} {
    allow read;
    allow write: if isEditor();
  }

  match /counters/{cid} {
    allow read;
    allow write: if isEditor() && isAdmin();
  }

  match /admin/{document=**} {
    allow read: if isAdmin();
    allow write: if isEditor() && isAdmin();
  }

  /// FUNCTIONS ///
  function isSignedIn() {
    return request.auth != null;
  }

  function getUserData() {
    return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
  }

  function userHasRole(role) {
    return getUserData().roles[role] == true;
  }

  function isAdmin() {
    return getUserData().roles['admin'] == true;
  }

  function isEditor() {
    return getUserData().roles['editor'] == true;
  }

  function isPremium() {
    return getUserData().roles['premium'] == true;
  }

  function userHasAnyRole(roles) {
    return getUserData().roles.keys().hasAny(roles);
  }

  function userHasAllRoles(roles) {
    return getUserData().roles.keys().hasAll(roles);
  }

  function isOwner(uid) {
    return request.auth.uid == uid;
  }

  function emailVerified() {
    return request.auth.token.email_verified;
  }

  function existingData() {
    return resource.data;
  }

  function incomingData() {
    return request.resource.data;
  }

  function currentUser() {
    return request.auth;
  }

  function isValidUser() {
    return incomingData().keys().hasAll([
        'creationTime',
        'uid',
        'displayName',
        'email',
        'roles',
        'stats'
    ]);
  }

  function isValidBook() {
    return incomingData().keys().hasAll([
        'ISBN_13',
        'authors',
        'bid',
        'EDIT',
        'pages_num',
        'publisher',
        'title',
        'title_sort',
        'readers_num',
        'reviews_num',
        'ratings_num',
        'rating_num'
    ])
      && incomingData().pages_num is int
      && incomingData().readers_num is int
      && incomingData().reviews_num is int
      && incomingData().ratings_num is int
      && incomingData().rating_num is int
  }
}

match /racerunner {
  // Licence: MIT (https://github.com/goracerunner/racerunner-web/blob/1c036d8caf9fbd7e108393b791b851890f7e3454/LICENSE)
  // https://github.com/goracerunner/racerunner-web/blob/1c036d8caf9fbd7e108393b791b851890f7e3454/config/firestore.rules
  //
  // Helper functions
  //

  // Type checks
  function isString(field) { return request.resource.data[field] is string }
  function isNumber(field) { return request.resource.data[field] is number }
  function isInt(field) { return request.resource.data[field] is int }
  function isFloat(field) { return request.resource.data[field] is float }
  function isBoolean(field) { return request.resource.data[field] is bool }
  function isList(field) { return request.resource.data[field] is list }
  function isMap(field) { return request.resource.data[field] is map }
  function isPath(field) { return request.resource.data[field] is path }
  function isTimestamp(field) { return request.resource.data[field] is timestamp }
  function isDuration(field) { return request.resource.data[field] is duration }
  function isLatlng(field) { return request.resource.data[field] is latlng }

  // Enforce that a field is unchanged
  function unchanged(field) {
    return request.resource.data[field] == resource.data[field]
  }

  // Enforce that a request has all the specified fields
  function fields(keys) {
    return request.resource.data.keys().hasAll(keys)
  }

  // Retrieve the current data in the requested data
  function data() {
    return resource.data
  }

  // Retrieve the new data that will be written to the document
  function newData() {
    return request.resource.data
  }


  //
  // Claims
  //

  // Enforce that the user has the specified claim
  function hasClaim(claim) {
    return claim in request.auth.token.keys() && request.auth.token[claim] == true
  }

  function hasClaimAdmin() { return hasClaim("admin") }
  function hasClaimManager() { return hasClaim("manager") }

  //
  // Access checks
  //

  function loggedIn() {
    return request.auth != null;
  }

  // Enforce that a request was from the user of the specified uid
  function requestFrom(uid) {
    return request.auth.uid == uid
  }

  // Enforce that a list field in the resource contains the requester's uid
  function fieldListsUser(doc) {
    return doc.hasAny([request.auth.uid])
  }

  function getData(path) {
    return get(path("/databases/{database}/documents/" + path).bind({ "database": database })).data
  }

  //
  // Request validations
  //



  //
  // Users
  //

  match /users/{uid} {
    // Allow all users to get public profiles
    allow get: if loggedIn()

      // Only allow admins to list all users
      allow list: if loggedIn() && hasClaimAdmin()

      // Only accessible by the owner and admins
      match /protected {
        match /details {
          // Allow read if it is the owner or an admin
          allow get: if loggedIn() &&
            (requestFrom(uid) || hasClaimAdmin())
        }
      }

    // Only accessible by admins
    match /private {
      match /claims {
        allow read, write: if loggedIn() && hasClaimAdmin()
      }
    }

    // Allow user to view list of races they are in
    match /races/{raceId} {
      allow read: if loggedIn() && requestFrom(uid)
    }

    match /managedRaces/{raceId} {
      allow read: if loggedIn() && requestFrom(uid) && hasClaimManager()
    }
  }


  //
  // Races
  //

  function isRaceParticipant(raceId) {
    return fieldListsUser(getData("races/" + raceId).participantIds)
  }

  function isRaceManager(raceId) {
    return fieldListsUser(getData("races/" + raceId).managerIds)
  }


  match /races/{raceId} {
    // Allow admins to get a race's details
    allow read: if loggedIn() && hasClaimAdmin()

      // Allow a participant/manager to get details about a race they are in
      allow get: if loggedIn() && (isRaceParticipant(raceId) || isRaceManager(raceId))

      // Allow admins to create races
      allow create: if loggedIn() && hasClaimAdmin()

      // Allow managers and admins to modify a race
      allow update: if loggedIn() && (isRaceManager(raceId) || hasClaimAdmin())

      match /registrationFields/{managerId} {
        // Allow all participants to see registration fields
        allow read: if loggedIn() && (isRaceParticipant(raceId) || isRaceManager(raceId))

          // Allow managers to modify registration fields
          allow write: if loggedIn() && isRaceManager(raceId)
      }

    match /registrations/{registrationId} {
      // Allow participants to create a registration once
      allow create: if loggedIn() && isRaceParticipant(raceId)

        // Allow user to view their own registration
        allow get: if loggedIn() && isRaceParticipant(raceId) && requestFrom(registrationId)

        // Allow all managers to view and update registrations
        allow read, update: if loggedIn() && isRaceManager(raceId)
    }

    match /managers/{managerId} {
      // Allow managers and admins to read managers
      allow read: if loggedIn() && (isRaceManager(raceId) || hasClaimAdmin())

        // Allow admins to manage managers
        allow write: if loggedIn() && hasClaimAdmin()
    }

    match /participants/{participantId} {
      // Allow participants, managers and admins to read participants
      allow read: if loggedIn() && (isRaceParticipant(raceId) || isRaceManager(raceId) || hasClaimAdmin())

        // Allow managers and admins to manage participants
        allow write: if loggedIn() && (isRaceManager(raceId) || hasClaimAdmin())
    }
  }


  //
  // Stats
  //

  match /stats/{stat} {
    // Only allow admins to view stats
    allow read: if loggedIn() && hasClaimAdmin()
  }
}

match /blockframes {
  // Licence: MIT (https://github.com/blockframes/blockframes/blob/01af5bc0358adb6c6eb2ab4f2e138b4495d67c6c/LICENSE)
  // https://github.com/blockframes/blockframes/blob/01af5bc0358adb6c6eb2ab4f2e138b4495d67c6c/firestore.rules
  match /{documents=**} {
    allow read, write;
  }

  // Note: Add a verification of each document ID => {id: ID_SHOULD_BE_EQUAL_TO_PATH}

  /// USERS RULES ///

  match /users/{userId} {
    allow read, update: if isSignedIn();
    allow create: if userId() == incomingData().uid;
  }

  /// NOTIFICATIONS RULES ///

  match /notifications/{notificationId} {
    allow read: if currentUser().uid == existingData().userId;
  }

  /// ORGANIZATION RULES ///

  match /orgs/{orgId} {
    allow create: if isSignedIn();
    allow read, update, delete: if isOrgAdmin(userId(), orgId);
  }

  /// PERMISSIONS RULES ///
  // What about moving permissions CRUD into firebase functions
  match /permissions/{orgId} {
    allow read, write;

    match /{documents=**} {
      allow read, write;
    }
  }

  /// MOVIES RULES ///

  match /movies/{movieId} {
    allow create: if orgCan('canCreate', userOrgId(), movieId)
      && userCan('canCreate', userId(), userOrgId(), movieId);
    allow read: if orgCan('canRead', userOrgId(), movieId)
      && userCan('canRead', userId(), userOrgId(), movieId);
    allow update: if orgCan('canUpdate', userOrgId(), movieId)
      && userCan('canUpdate', userId(), userOrgId(), movieId);
    allow delete: if orgCan('canDelete', userOrgId(), movieId)
      && userCan('canDelete', userId(), userOrgId(), movieId);

    match /{documents=**} {
      allow read, write;
    }
  }

  /// DELIVERIES RULES ///

  match /deliveries/{deliveryId} {
    allow create: if orgCan('canCreate', userOrgId(), deliveryId)
      && userCan('canCreate', userId(), userOrgId(), deliveryId);
    allow read: if orgCan('canRead', userOrgId(), deliveryId)
      && userCan('canRead', userId(), userOrgId(), deliveryId);
    allow update: if orgCan('canUpdate', userOrgId(), deliveryId)
      && userCan('canUpdate', userId(), userOrgId(), deliveryId);
    allow delete: if orgCan('canDelete', userOrgId(), deliveryId)
      && userCan('canDelete', userId(), userOrgId(), deliveryId);

    match /{documents=**} {
      allow read, write;
    }
  }

  /// TEMPLATES RULES ///

  match /templates/{templateId} {
    allow create: if orgCan('canCreate', userOrgId(), templateId)
      && userCan('canCreate', userId(), userOrgId(), templateId);
    allow read: if orgCan('canRead', userOrgId(), templateId)
      && userCan('canRead', userId(), userOrgId(), templateId);
    allow update: if orgCan('canUpdate', userOrgId(), templateId)
      && userCan('canUpdate', userId(), userOrgId(), templateId);
    allow delete: if orgCan('canDelete', userOrgId(), templateId)
      && userCan('canDelete', userId(), userOrgId(), templateId);

    match /{documents=**} {
      allow read, write;
    }
  }


  /// FUNCTIONS ///

  function existingData() {
    return resource.data;
  }

  function incomingData() {
    return request.resource.data;
  }

  function currentUser() {
    return request.auth;
  }

  function userId() {
    return currentUser().uid;
  }

  function isSignedIn() {
    return currentUser() != null;
  }

  function userOrgId() {
    return get(/databases/$(database)/documents/users/$(userId())).data.orgId;
  }

  function isSuperAdmin(userId, orgId) {
    return userId in getOrgPermissions(orgId).superAdmins;
  }

  function isOrgAdmin(userId, orgId) {
    // /!\ Carefull, parentheses needed for operator precedence to work
    return (userId in getOrgPermissions(orgId).admins)
      || isSuperAdmin(userId, orgId);
  }

  function getOrgDocumentPermissions(orgId, docId) {
    return get(/databases/$(database)/documents/permissions/$(orgId)/orgDocsPermissions/$(docId)).data;
  }

  function getOrgPermissions(orgId) {
    return get(/databases/$(database)/documents/permissions/$(orgId)).data;
  }

  function getUserDocumentPermissions(orgId, docId) {
    return get(/databases/$(database)/documents/permissions/$(orgId)/userDocsPermissions/$(docId)).data;
  }

  // Parameter "action" can either be "canCreate", "canRead", "canUpdate" or "canDelete"
  function orgCan(action, orgId, docId) {
    return (getOrgDocumentPermissions(orgId, docId).owner == orgId)
      || (getOrgDocumentPermissions(orgId, docId).admin == true)
      || (getOrgDocumentPermissions(orgId, docId)[action] == true);
  }

  function userCan(action, userId, orgId, docId) {
    return isOrgAdmin(userId, orgId)
      || (userId in getOrgPermissions(orgId)[action])
      || (userId in getUserDocumentPermissions(orgId, docId).admins)
      || (userId in getUserDocumentPermissions(orgId, docId)[action]);
  }
}

match /social {
  // Licence: MIT (https://github.com/red-gold/social-firebase/blob/4f27ee82f4f4c975599153f6f17c562284979a03/LICENSE)
  // https://github.com/red-gold/social-firebase/blob/4f27ee82f4f4c975599153f6f17c562284979a03/firestore.rules
  match /users/{userId}/circles/{circleId} {
    allow read, write: if allAuthed(userId);
  }
  match /users/{userId}/videos/{circleId} {
    allow read, write: if allAuthed(userId);
  }
  match /users/{userId}/videos/{videoId} {
    allow read, write: if allAuthed(userId);
  }
  match /users/{userId}/images/{imageId} {
    allow read, write: if true //allAuthed(userId);
  }
  match /album/{albumId}/photos/{photoId} {
    allow read, write: if true //allAuthed(incomingData().ownerUserId);
  }
  match /album/{albumId}{
    allow read, write: if true //allAuthed(incomingData().ownerUserId);
  }
  match /userSetting/{userId} {
    allow read, write: if allAuthed(userId);
  }
  match /users/{userId}/notifications/{notifyId} {
    allow read: if allAuthed(userId) ;
    allow create: if isAdmin() ;
    allow update: if allAuthed(userId) ;
    allow delete: if allAuthed(userId) ;
  }
  match /verification/{userId} {
    allow read, write: if isAdmin();
  }
  match /userSecret/{userId} {
    allow read, write: if isAdmin();
  }
  match /userInfo/{userId} {
    allow read: if isAuthed();
    allow write: if allAuthed(userId) && incomingData().userId == userId;
  }
  match /posts/{postId} {
    allow read: if hasPermission() || isAdmin();
    //allow create: if isAuthed() ;
    allow create: if incomingData().ownerUserId == request.auth.uid || isAdmin() ;
    allow update: if existingData().ownerUserId == request.auth.uid || isAdmin() ;
    allow delete: if existingData().ownerUserId == request.auth.uid || isAdmin() ;
  }
  match /posts/{postId}/votes/{voteId} {
    allow read: if isAdmin();
    allow create: if incomingData().userId == request.auth.uid || isAdmin() ;
    allow update: if existingData().userId == request.auth.uid || isAdmin() ;
    allow delete: if existingData().userId == request.auth.uid || isAdmin();
  }
  match /graphs:users/{nodeId}{
    allow read: if existingData().leftNode == request.auth.uid
      || existingData().rightNode == request.auth.uid || isAdmin();
    allow create: if incomingData().leftNode == request.auth.uid || isAdmin() ;
    allow update: if existingData().leftNode == request.auth.uid || isAdmin() ;
    allow delete: if existingData().leftNode == request.auth.uid || isAdmin();
  }
  match /feeds/{feedId}{
    allow read: if isAdmin();
    allow create: if incomingData().user.userId == request.auth.uid || isAdmin() ;
    allow update: if (existingData().user.userId == request.auth.uid
        && incomingData().user.userId == request.auth.uid
        )|| isAdmin() ;
    allow delete: if existingData().user.userId == request.auth.uid || isAdmin();
  }
  match /comments/{commentId}{
    allow read: if isAuthed();
    allow create: if incomingData().userId == request.auth.uid || isAdmin() ;
    allow update: if canUpdateComment() || isAdmin() ;
    allow delete: if get(/databases/$(database)/documents/posts/$(existingData().postId)).data.ownerUserId == request.auth.uid
      || isAdmin()
      || existingData().userId == request.auth.uid;
  }
  match /chatroom/{roomId}{
    allow read: if request.auth.uid in existingData().connections
      || isAdmin();
    allow create: if request.auth.uid in incomingData().connections
      || isAdmin();
    allow update: if (request.auth.uid in incomingData().connections
        && request.auth.uid in existingData().connections)
      || isAdmin();
    allow delete: if request.auth.uid in existingData().connections
      || isAdmin();
  }
  match /chatroom/{roomId}/messages/{messageId}{
    allow read: if request.auth.uid in get(/databases/$(database)/documents/chatroom/$(roomId)).data.connections
      || isAdmin();
    allow create: if request.auth.uid in get(/databases/$(database)/documents/chatroom/$(roomId)).data.connections
      || isAdmin();
    allow update: if request.auth.uid in get(/databases/$(database)/documents/chatroom/$(roomId)).data.connections
      || isAdmin();
    allow delete: if request.auth.uid in get(/databases/$(database)/documents/chatroom/$(roomId)).data.connections
      || isAdmin();
  }

  // *** Comments ***
  //
  //
  // Return true if current user can update the commnet
  function canUpdateComment() {
    return incomingData().userId == request.auth.uid && existingData().userId == request.auth.uid
  }

  // *** Posts ***
  //
  //
  // Return true if user has access permission to the entity
  function hasPermission() {
    return existingData().ownerUserId == request.auth.uid ||  existingData().permission == 'Public' || request.auth.uid in existingData().accessUserList
  }


  // *** Authorization ***
  //
  //
  // All authed accepted
  function allAuthed(userId) {
    return isOwner(userId) || isAdmin();
  }


  // Returns true if the user is the owner of the file.
  function isOwner(uid) {
    return request.auth.uid == uid;
  }

  // Returns true if the user is signed in.
  function isAuthed() {
    return request.auth != null;
  }

  // Returns true if the user that initiated the request is an admin.
  function isAdmin() {
    return request.auth.token != null && request.auth.token.admin == true;
  }

  // If user phone is verified
  function phoneVerified() {
    return request.auth.token.phoneVerified;
  }

  // if user email is verified
  function emailVerified() {
    return request.auth.token.email_verified;
  }

  // Returns existing data
  function existingData() {
    return resource.data;
  }

  // Returns incoming data
  function incomingData() {
    return request.resource.data;
  }

  // Get user information
  function getUserInfo(userId) {
    return get(/databases/$(database)/documents/userInfo/$(userId));
  }

  // Get user information
  function getPost(postId) {
    return get(/databases/$(database)/documents/posts/$(postId));
  }
}

match /tutorbook {
  // Licence: MIT (https://github.com/nicholaschiang/tutorbook/blob/61a3186b1de8ea092705a5346ef49448aed73da7/LICENSE)
  // https://github.com/nicholaschiang/tutorbook/blob/61a3186b1de8ea092705a5346ef49448aed73da7/build/firestore.rules

  // [SPECIAL ACCESS]
  match /auth/{document=**} {
    allow read: if request.auth.uid != null;
  }
  match /locations/{location} {
    allow read: if request.auth.uid != null;
    allow update, delete: if request.auth.token.email in resource.data.supervisors;
    allow create: if request.auth.token.email in request.resource.data.supervisors
      && request.auth.token.supervisor == true;
  }
  match /users/{supervisor}/dismissedCards/{card} {
    // Workaround to enable supervisors to dismiss cards (as we don't want
    // them deleting that actual document).
    allow read, create: if request.auth.token.email == supervisor;
  }

  // [SEARCH]
  match /search/{user} {
    allow read: if true;
  }
  // [USER PROFILES]
  match /users/{user} {
    // to become an admin or supervisor without actually knowing the code.
    allow read: if request.auth.uid != null;
    allow create: if (request.auth.token.email == user
        || request.auth.token.supervisor)
      && request.resource.data.payments.currentBalance == 0
      && request.resource.data.payments.currentBalanceString == "$0.00"
      && request.resource.data.secondsPupiled == 0
      && request.resource.data.secondsTutored == 0;
    allow delete: if request.auth.token.email == user
      || request.auth.token.email in resource.data.proxy
      || request.auth.token.supervisor;
    allow update: if (request.auth.token.email == user
        || request.auth.token.email in resource.data.proxy
        || request.auth.token.supervisor)
      // of the supervisor's location(s)
      && (
          !("currentBalance" in request.resource.data.payments)
          || ("currentBalance" in request.resource.data.payments && request.resource.data.payments.currentBalance == resource.data.payments.currentBalance)
         )
      && (
          !("currentBalanceString" in request.resource.data.payments)
          || ("currentBalanceString" in request.resource.data.payments && request.resource.data.payments.currentBalanceString == resource.data.payments.currentBalanceString)
         )
      && (
          !("secondsPupiled" in request.resource.data)
          || ("secondsPupiled" in request.resource.data && request.resource.data.secondsPupiled == resource.data.secondsPupiled)
         )
      && (
          !("secondsTutored" in request.resource.data)
          || ("secondsTutored" in request.resource.data && request.resource.data.secondsTutored == resource.data.secondsTutored)
         );
  }

  // [REQUESTS IN]
  match /{path=**}/requestsIn/{requestIn} {
    // collectionGroup query rules for supervisors and admins
    // Allow supervisors to read docs that are at their location
    allow read: if resource.data.location.id in request.auth.token.locations;
  }
  match /users/{user}/requestsIn/{requestIn} {
    allow read: if request.auth.token.email == user
      || request.auth.token.email == resource.data.fromUser.email
      || (request.auth.token.email in resource.data.fromUser.proxy
          || request.auth.token.email in resource.data.toUser.proxy);
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /{path=**}/modifiedRequestsIn/{requestIn} {
    // collectionGroup query rules for supervisors and admins
    // Allow supervisors to read docs that are at their location
    allow read: if resource.data.for.location.id in request.auth.token.locations;
  }
  match /users/{user}/modifiedRequestsIn/{requestIn} {
    // fromUser creates this document and the toUser dismisses it
    // Users should never need to update this document
    allow read, delete: if request.auth.token.email == user
      || request.auth.token.email in resource.data.for.toUser.proxy;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /{path=**}/canceledRequestsIn/{requestIn} {
    // collectionGroup query rules for supervisors and admins
    // Allow supervisors to read docs that are at their location
    allow read: if resource.data.for.location.id in request.auth.token.locations;
  }
  match /users/{user}/canceledRequestsIn/{requestIn} {
    // fromUser creates this document and the toUser dismisses it
    allow read, delete: if request.auth.token.email == user
      || request.auth.token.email in resource.data.for.toUser.proxy;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }

  // [REQUESTS OUT]
  match /{path=**}/requestsOut/{requestOut} {
    // collectionGroup query rules for supervisors and admins
    // Allow supervisors to read docs that are at their location
    allow read: if resource.data.location.id in request.auth.token.locations;
  }
  match /users/{user}/requestsOut/{requestOut} {
    allow read: if request.auth.token.email == user
      || request.auth.token.email == resource.data.toUser.email
      || (request.auth.token.email in resource.data.fromUser.proxy
          || request.auth.token.email in resource.data.toUser.proxy);
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /{path=**}/modifiedRequestsOut/{requestOut} {
    // collectionGroup query rules for supervisors and admins
    // Allow supervisors to read docs that are at their location
    allow read: if resource.data.for.location.id in request.auth.token.locations;
  }
  match /users/{user}/modifiedRequestsOut/{requestOut} {
    // toUser creates this document and the fromUser dismisses it
    allow read, delete: if request.auth.token.email == user
      || request.auth.token.email in resource.data.for.fromUser.proxy;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /{path=**}/rejectedRequestsOut/{requestOut} {
    // collectionGroup query rules for supervisors and admins
    // Allow supervisors to read docs that are at their location
    allow read: if resource.data.for.location.id in request.auth.token.locations;
  }
  match /users/{user}/rejectedRequestsOut/{requestOut} {
    // toUser creates this document and the fromUser dismisses it
    allow read, delete: if request.auth.token.email == user
      || request.auth.token.email in resource.data.for.fromUser.proxy;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /{path=**}/approvedRequestsOut/{requestOut} {
    // collectionGroup query rules for supervisors and admins
    // Allow supervisors to read docs that are at their location
    allow read: if resource.data.for.location.id in request.auth.token.locations;
  }
  match /users/{user}/approvedRequestsOut/{requestOut} {
    // toUser creates this document and the fromUser dismisses it
    allow read, delete: if request.auth.token.email == user
      || request.auth.token.email in resource.data.for.fromUser.proxy;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }

  // [APPOINTMENTS]
  match /users/{user}/appointments/{appt} {
    // We have to specify that the given user can read all of their appts b/c
    // otherwise, we'd have to specify it in the query itself, which is too
    // much of a hassle and leads to confusing code.
    allow read: if request.auth.token.email == user
      || request.auth.token.email in
      [resource.data.attendees[0].email, resource.data.attendees[1].email]
      || request.auth.token.email in resource.data.attendees[0].proxy
        || request.auth.token.email in resource.data.attendees[1].proxy
        || resource.data.location.id in request.auth.token.locations;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /locations/{location}/appointments/{appt} {
    allow read: if request.auth.token.email in
      [resource.data.attendees[0].email, resource.data.attendees[1].email]
      || request.auth.token.email in resource.data.attendees[0].proxy
        || request.auth.token.email in resource.data.attendees[1].proxy
        || location in request.auth.token.locations;
  }
  match /locations/{location}/modifiedAppointments/{appt} {
    allow read, delete: if location in request.auth.token.locations;
  }
  match /users/{user}/modifiedAppointments/{appt} {
    // Either attendee can create and dismiss this card
    allow read, delete: if request.auth.token.email == user
      || request.auth.token.email in
      [resource.data.for.attendees[0].email, resource.data.for.attendees[1].email]
      || request.auth.token.email in resource.data.for.attendees[0].proxy
        || request.auth.token.email in resource.data.for.attendees[1].proxy;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /{path=**}/canceledAppointments/{appt} {
    // collectionGroup query rules for supervisors and admins
    // Allow supervisors to read docs that are at their location
    // Supervisors can also cancel appointments at their location
    allow read: if resource.data.for.location.id in request.auth.token.locations;
  }
  match /users/{user}/canceledAppointments/{appt} {
    // Either attendee can create and dismiss this card
    allow read, delete: if request.auth.token.email == user
      || request.auth.token.email in
      [resource.data.for.attendees[0].email, resource.data.for.attendees[1].email]
      || request.auth.token.email in resource.data.for.attendees[0].proxy
        || request.auth.token.email in resource.data.for.attendees[1].proxy;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /locations/{location}/canceledAppointments/{appt} {
    // Only allow a user to create if they were already allowed to create a
    // canceledAppt doc in the other user's.
    allow read, delete: if location in request.auth.token.locations;
  }

  // [CLOCKINS AND CLOCKOUTS]
  match /users/{supervisor}/clockIns/{clockIn} {
    allow read: if request.auth.token.email == supervisor;
  }
  match /users/{supervisor}/approvedClockIns/{clockIn} {
    allow read: if request.auth.token.email == resource.data.sentBy.email;
  }
  match /users/{user}/activeAppointments/{appt} {
    allow read: if request.auth.token.email == user
      || resource.data.location.id in request.auth.token.locations;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /locations/{location}/activeAppointments/{appt} {
    allow read: if location in request.auth.token.locations
      || request.auth.token.email == resource.data.attendees[0].email
      || request.auth.token.email == resource.data.attendees[1].email;
  }
  match /users/{supervisor}/rejectedClockIns/{clockIn} {
    allow read: if request.auth.token.email == resource.data.sentBy.email;
  }
  match /users/{supervisor}/clockOuts/{clockOut} {
    allow read: if request.auth.token.email == supervisor;
  }
  match /users/{supervisor}/approvedClockOuts/{clockOut} {
    allow read: if request.auth.token.email == resource.data.sentBy.email;
  }
  match /users/{user}/pastAppointments/{appt} {
    allow read: if request.auth.token.email == user
      || resource.data.location.id in request.auth.token.locations;
    allow read: if request.auth.token.email in
      get(/databases/$(database)/documents/users/$(user)).data.proxy;
  }
  match /locations/{location}/pastAppointments/{appt} {
    allow read: if request.auth.token.supervisor == true
      && location in request.auth.token.locations;
  }
  match /users/{supervisor}/rejectedClockOuts/{clockOut} {
    allow read: if request.auth.token.email == resource.data.sentBy.email;
  }

  // [PAYMENTS]
  match /users/{user}/approvedPayments/{payment} {
    allow create: if request.auth.token.email == user
      || request.auth.token.email == request.resource.data.from.email;
    allow read: if request.auth.token.email == resource.data.to.email
      || request.auth.token.email == resource.data.from.email;
  }
  match /stripeAccounts/{user} {
    allow read: if request.auth.token.email == user;
  }
  match /users/{user}/sentPayments/{payment} {
    allow create: if request.auth.token.email == user;
  }
  match /users/{user}/requestedPayments/{payment} {
    allow create: if request.auth.token.email ==
      request.resource.data.to.email;
    allow read, delete: if request.auth.token.email == user;
  }
  match /users/{user}/requestedPayouts/{payout} {
    allow create, read: if request.auth.token.email == user;
  }
  match /users/{user}/deniedPayments/{payment} {
    allow read: if request.auth.token.email == user;
    allow create: if request.auth.token.email ==
      request.resource.data.deniedBy.email;
  }
  match /users/{user}/approvedPayments/{payment} {
    allow read: if request.auth.token.email == user;
    allow create: if request.auth.token.email ==
      request.resource.data.approvedBy.email;
  }
  match /users/{user}/needApprovalPayments/{payment} {
    allow read, delete: if request.auth.token.email == user;
  }
  match /users/{user}/authPayments/{payment} {
    allow read: if request.auth.token.email == user;
    allow create: if request.auth.token.email == request.resource.data.from.email
      || request.auth.token.email == request.resource.data.to.email;
    // When a request is canceled or rejected, client removes this document.
    allow delete: if request.auth.token.email == resource.data.from.email
      || request.auth.token.email == resource.data.to.email;
  }
  match /users/{user}/pastPayments/{payment} {
    allow read: if request.auth.token.email == user;
  }
  match /users/{user}/paidPayments/{payment} {
    allow read: if request.auth.token.email == user;
  }
  match /users/{user}/invalidPayments/{payment} {
    allow read: if request.auth.token.email == user;
  }

  // [CHATS]
  match /chats/{chat} {
    allow read, write: if request.auth.token.email in resource.data.chatterEmails;
    allow create: if request.auth.token.email in
      request.resource.data.chatterEmails;
    match /messages/{message} {
      allow read, create: if request.auth.token.email in
        get(/databases/$(database)/documents/chats/$(chat)).data.chatterEmails;
      allow update, delete: if request.auth.token.email ==
        resource.data.sentBy.email;
    }
  }
}
